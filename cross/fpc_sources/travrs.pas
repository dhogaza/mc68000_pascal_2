{[b+,o=80]}
{ NOTICE OF COPYRIGHT AND OWNERSHIP OF SOFTWARE:

  Copyright (C) 1986, 1987, 1988, 1989, 1990 Oregon Software, Inc.
  All Rights Reserved.

  This program is the property of Oregon Software.  The program or
  parts of it may be copied and used only as provided under a signed
  license agreement with Oregon Software.  Any support purchased from
  Oregon Software does not apply to user-modified programs.  All copies
  of this program must display this notice and all copyright notices.

        @(#)travrs.pas	4.4  7/31/90  16:31:36


  Pascal-2 Compiler Tree Builder

 Last modified by KRIS on 21-Nov-1990 15:23:35
 Purpose:
 Update release version for PC-VV0-GS0 at 2.3.0.1

}

{ Tree building, improving and walking.

  This procedure takes data from the intermediate file generated by
  analys, and builds a full tree representation of each procedure as
  it is read.  As the tree is being built, common subexpressions are
  detected and links to them inserted in place of later occurrences.
  Also, dead code that is recognized during the building process is deleted
  by simply not linking it into the tree.  During the building operation,
  values that are assigned to simple variables are recorded and any further
  references to such variables are replaced by references to constants.
  This also allows more folding of expresssions to be detected and
  computed.

  During the building process, once a loop is entered, special operations
  are performed for the duration of the loop.  Each entry point to a
  loop (a basic block) maintains a linked list of the var's read and
  written in the loop.  This allows the improve phase to determine
  which expressions are invariant and may be hoisted.

  Also during the building process references to local variables are
  monitored to determine their suitability for register allocation.  Doing
  this in travrs instead of analys has several advantages.  First, references
  to var's within deadcode don't pollute the reference counts of the var.
  Second, lifetime analysis is done, which allows multiple var's to be
  assigned to a single register.

  Once the tree is built, local var's are assigned to registers, loops are
  examined, and invariant hoisting is performed.

  Finally, the tree is walked and "pseudocode" is generated for the
  code generation pass to use.  Along with the actual operations, that
  portion of the tree which is currently active is passed to the code
  generator for its use.  This provides the code generator with all
  of the data it might need, while conserving space in the code
  generation process.

  Since the tree can become quite large, most of it is built in a
  virtual storage area which is paged to a file.  The tree consists
  of three hierarchical structures:  basic blocks, statements, and
  expressions.  Each basic block consists of a group of statements,
  with one entry point and one or more exits.  Each statement can
  consist of several expressions.  The basic block structure, because
  it is generally small, and traversed often, is kept in the heap.
  Statements and expressions are implemented in the virtual store.
}

unit travrs;

interface

uses config, hdr, utils, error, a_t, t_c, hdrt, commont, fpcalc,
     foldcom, improve, walk;

procedure travrs;

implementation

procedure inittravrs;

{ Initialize structured constants (tables) and counters.
}

  var
    i: integer; {induction var for initializing virtual memory}
    j: 0..nodesperblock; { induction var so building ptrs }
    o: operatortype; {induction var for initializing map}
    t, t1: types; {induction vars for initializing maps}
    p: proctableindex; {induction for initializing referenced field}


  procedure map1;

{ Initialize the map which takes input operators and types onto pseudocode.
  This is split into three routines to reduce the size of the code for
  each routine.
}


    begin {[s=2] Format two assignments per line}
      map[indxchkop, ints] := indxchk;     map[rangechkop, ints] := rangechk;
      map[cindxchkop, ints] := indxchk;    map[ownop, ints] := doown;
      map[congruchkop, ints] := congruchk; map[levop, ints] := dolevel;
      map[intop, ints] := doint;           map[originop, ints] := doorigin;
      map[ptrop, ints] := doptr;           map[realop, ints] := doreal;
      map[structop, ints] := dostruct;     map[moveop, ints] := movint;
      map[moveop, reals] := movreal;       map[moveop, bools] := movint;
      map[moveop, chars] := movint;        map[moveop, ptrs] := movptr;
      map[moveop, scalars] := movint;      map[moveop, arrays] := movstruct;
      map[moveop, fields] := movstruct;    map[moveop, sets] := movset;
      map[moveop, strings] := movstr;      map[moveop, fptrs] := movptr;
      map[moveop, words] := movint;        map[moveop, opaques] := movptr;
      map[moveop, bytes] := movint;
      map[moveop, stringliterals] := movstruct;
      map[moveop, procs] := movptr;        map[cmoveop, arrays] := movcstruct;
      map[movelit, words] := movlitint;    map[movelit, opaques] := movlitptr;
      map[movelit, ints] := movlitint;     map[movelit, chars] := movlitint;
      map[movelit, bools] := movlitint;    map[movelit, ptrs] := movlitptr;
      map[movelit, scalars] := movlitint;  map[movelit, reals] := movlitreal;
      map[movelit, fptrs] := movlitptr;    map[movelit, procs] := movlitptr;
      map[movelit, bytes] := movlitint;    map[chrstrop, strings] := chrstr;
      map[chrstrop, stringliterals] := chrstr;
      map[arraystrop, strings] := arraystr;
      map[arraystrop, stringliterals] := arraystr;
      map[chrstrop, chars] := chrstr;      map[arraystrop, arrays] := arraystr;
      map[chrstrop1, stringliterals] := chrstr;
      map[arraystrop1, stringliterals] := arraystr;
      map[chrstrop1, strings] := chrstr;
      map[arraystrop1, strings] := arraystr;
      map[plusop, ints] := addint;         map[plusop, ptrs] := addptr;
      map[plusop, strings] := addstr;      map[plusop, reals] := addreal;
      map[plusop, sets] := addset;         map[plusop, scalars] := addint;
      map[minusop, ints] := subint;        map[minusop, scalars] := subint;
      map[minusop, ptrs] := subptr;        map[minusop, reals] := subreal;
      map[minusop, sets] := subset;        map[notop, bools] := compbool;
      map[notop, ints] := compint;         map[notop, scalars] := compint;
      map[inop, sets] := inset;            map[andop, ints] := andint;
      map[andop, bools] := andint;         map[andop, scalars] := andint;
      map[andop, ptrs] := andint;          map[orop, ints] := orint;
      map[orop, bools] := orint;           map[orop, scalars] := orint;
      map[orop, ptrs] := orint;            map[incop, ints] := incint;
      map[decop, ints] := decint;          map[indxop, ints] := indx;
      map[indrop, ints] := indxindr;       map[openarrayop, ints] := openarray;
      map[filebufindrop, ints] := indxindr;
      map[aindxop, ints] := aindx;         map[mulop, ints] := mulint;
      map[mulop, reals] := mulreal;        map[mulop, sets] := mulset;
      map[mulop, scalars] := mulint;       map[divop, scalars] := divint;
      map[divop, ints] := divint;          map[stddivop, ints] := stddivint;
      map[slashop, sets] := divset;        map[slashop, reals] := divreal;
      map[quoop, ints] := getquo;          map[remop, ints] := getrem;
      map[shiftlop, ints] := shiftlint;    map[pindxop, ints] := pindx;
      map[paindxop, ints] := paindx;       map[eqop, procs] := eqptr;
      map[eqop, strings] := eqstr;         map[eqop, ints] := eqint;
      map[eqop, chars] := eqint;           map[eqop, bools] := eqint;
      map[eqop, ptrs] := eqptr;            map[eqop, fptrs] := eqfptr;
      map[eqop, scalars] := eqint;         map[eqop, reals] := eqreal;
      map[eqop, sets] := eqset;            map[eqop, arrays] := eqstruct;
      map[eqop, words] := eqint;           map[eqop, opaques] := eqptr;
      map[eqop, bytes] := eqint;           map[neqop, words] := neqint;
      map[neqop, opaques] := neqptr;       map[neqop, procs] := neqptr;
      map[neqop, strings] := neqstr;       map[neqop, ints] := neqint;
      map[neqop, chars] := neqint;         map[neqop, bools] := neqint;
      map[neqop, ptrs] := neqptr;          map[neqop, fptrs] := neqfptr;
      map[ptrchkop, ints] := ptrchk;       map[neqop, bytes] := neqint;
      { new for 32k }                      map[kwoop, ints] := kwoint;
      map[modop, ints] := modint;          map[stdmodop, ints] := stdmodint;

    end; {[s=1] map1}


  procedure map2;

{ More map initialization.
}


    begin {[s=2] Format two assignments per line}
      map[neqop, scalars] := neqint;       map[neqop, reals] := neqreal;
      map[neqop, sets] := neqset;          map[neqop, arrays] := neqstruct;
      map[lssop, strings] := lssstr;       map[lssop, ints] := lssint;
      map[lssop, chars] := lssint;         map[lssop, bools] := lssint;
      map[lssop, ptrs] := lssptr;          map[lssop, scalars] := lssint;
      map[lssop, reals] := lssreal;        map[lssop, arrays] := lssstruct;
      map[gtrop, ints] := gtrint;          map[gtrop, strings] := gtrstr;
      map[gtrop, chars] := gtrint;         map[gtrop, bools] := gtrint;
      map[gtrop, ptrs] := gtrptr;          map[gtrop, scalars] := gtrint;
      map[gtrop, reals] := gtrreal;        map[gtrop, arrays] := gtrstruct;
      map[geqop, strings] := geqstr;       map[geqop, ints] := geqint;
      map[geqop, chars] := geqint;         map[geqop, bools] := geqint;
      map[geqop, ptrs] := geqptr;          map[geqop, scalars] := geqint;
      map[geqop, reals] := geqreal;        map[geqop, sets] := geqset;
      map[geqop, arrays] := geqstruct;     map[leqop, strings] := leqstr;
      map[leqop, ints] := leqint;          map[leqop, chars] := leqint;
      map[leqop, bools] := leqint;         map[leqop, ptrs] := leqptr;
      map[leqop, scalars] := leqint;       map[leqop, reals] := leqreal;
      map[leqop, sets] := leqset;          map[leqop, arrays] := leqstruct;
      map[eqlit, procs] := eqlitptr;       map[eqlit, ints] := eqlitint;
      map[eqlit, reals] := eqlitreal;      map[eqlit, chars] := eqlitint;
      map[eqlit, ptrs] := eqlitptr;        map[eqlit, scalars] := eqlitint;
      map[eqlit, bools] := eqlitint;       map[eqlit, fptrs] := eqlitfptr;
      map[eqlit, words] := eqlitint;       map[eqlit, opaques] := eqlitptr;
      map[eqlit, bytes] := eqlitint;       map[neqlit, words] := neqlitint;
      map[neqlit, opaques] := neqlitptr;   map[neqlit, ints] := neqlitint;
      map[neqlit, procs] := neqlitptr;     map[neqlit, reals] := neqlitreal;
      map[neqlit, chars] := neqlitint;     map[neqlit, ptrs] := neqlitptr;
      map[neqlit, scalars] := neqlitint;   map[neqlit, bools] := neqlitint;
      map[neqlit, fptrs] := neqlitfptr;    map[neqlit, bytes] := neqlitint;
      map[lsslit, ints] := lsslitint;      map[lsslit, reals] := lsslitreal;
      map[lsslit, chars] := lsslitint;     map[lsslit, ptrs] := lsslitptr;
      map[lsslit, scalars] := lsslitint;   map[lsslit, bools] := lsslitint;
      map[gtrlit, ints] := gtrlitint;      map[gtrlit, reals] := gtrlitreal;
      map[gtrlit, chars] := gtrlitint;     map[gtrlit, ptrs] := gtrlitptr;
      map[gtrlit, scalars] := gtrlitint;   map[gtrlit, bools] := gtrlitint;
      map[leqlit, ints] := leqlitint;      map[leqlit, reals] := leqlitreal;
      map[leqlit, chars] := leqlitint;     map[leqlit, ptrs] := leqlitptr;
      map[leqlit, scalars] := leqlitint;   map[leqlit, bools] := leqlitint;
    end; {[s=1] map2}


  procedure map3;

{ Yet more map initialization.
}

    var
      i: types; {induction var}


    begin {[s=2] Format two assignments per line}
      map[wr, files] := wrbin;             map[rd, files] := rdbin;
      map[geqlit, ints] := geqlitint;      map[geqlit, reals] := geqlitreal;
      map[geqlit, chars] := geqlitint;     map[geqlit, ptrs] := geqlitptr;
      map[geqlit, scalars] := geqlitint;   map[geqlit, bools] := geqlitint;
      map[pushaddr, none] := pshaddr;      map[pushproc, none] := pshproc;
      map[pushaddr, strings] := pshaddr;   map[pushaddr, ints] := pshaddr;
      map[pushaddr, arrays] := pshaddr;    map[pushaddr, ptrs] := pshaddr;
      map[pushaddr, fields] := pshaddr;    map[pushaddr, chars] := pshaddr;
      map[pushaddr, reals] := pshaddr;     map[pushaddr, scalars] := pshaddr;
      map[pushaddr, bools] := pshaddr;     map[pushaddr, sets] := pshaddr;
      map[pushaddr, files] := pshaddr;     map[pushaddr, opaques] := pshaddr;
      map[pushaddr, words] := pshaddr;     map[pushaddr, bytes] := pshaddr;
      map[pushaddr, conformantarrays] := pshaddr;
      map[pushaddr, stringliterals] := pshaddr;
      map[pushaddr, procs] := pshaddr;     map[pushaddr, flexarrays] := pshaddr;
      map[pushstraddr, strings] := pshstraddr;
      map[pushlitvalue, procs] := pshlitptr;
      map[pushlitvalue, bools] := pshlitint;
      map[pushlitvalue, chars] := pshlitint;
      map[pushlitvalue, scalars] := pshlitint;
      map[pushlitvalue, ptrs] := pshlitptr;
      map[pushlitvalue, fptrs] := pshlitfptr;
      map[pushlitvalue, ints] := pshlitint;
      map[pushlitvalue, bytes] := pshlitint;
      map[pushlitvalue, reals] := pshlitreal;
      map[defforindexop, ints] := defforindex;
      map[defforlitindexop, ints] := defforlitindex;
      map[defunsforindexop, ints] := defunsforindex;
      map[defunsforlitindexop, ints] := defunsforlitindex;
      map[forupchkop, ints] := forupchk;   map[fordnchkop, ints] := fordnchk;
      map[forerrchkop, ints] := forerrchk; map[pushfinal, ints] := pshint;
      map[pushvalue, stringliterals] := pshstruct;
      map[pushvalue, procs] := pshptr;     map[pushvalue, opaques] := pshptr;
      map[pushvalue, ints] := pshint;      map[pushvalue, reals] := pshreal;
      map[pushvalue, chars] := pshint;     map[pushvalue, ptrs] := pshptr;
      map[pushvalue, scalars] := pshint;   map[pushvalue, arrays] := pshstruct;
      map[pushvalue, fields] := pshstruct; map[pushvalue, sets] := pshset;
      map[pushvalue, bools] := pshint;     map[pushvalue, strings] := pshstr;
      map[pushvalue, fptrs] := pshptr;     map[pushvalue, bytes] := pshint;
      map[pushvalue, words] := pshint;     map[pushvalue, doubles] := pshreal;

      map[pushcvalue, stringliterals] := pshstruct;
      map[pushcvalue, procs] := pshptr;    map[pushcvalue, opaques] := pshptr;
      map[pushcvalue, ints] := pshint;     map[pushcvalue, reals] := pshreal;
      map[pushcvalue, chars] := pshint;    map[pushcvalue, ptrs] := pshptr;
      map[pushcvalue, scalars] := pshint;  map[pushcvalue, arrays] := pshstruct;
      map[pushcvalue, fields] := pshstruct;
      map[pushcvalue, sets] := pshset;     map[pushcvalue, bools] := pshint;
      map[pushcvalue, strings] := pshstr;  map[pushcvalue, fptrs] := pshptr;
      map[pushcvalue, bytes] := pshint;    map[pushcvalue, words] := pshint;
      map[pushcvalue, doubles] := pshreal;

      map[bldfmt, none] := fmt;            map[wr, ints] := wrint;
      map[wr, reals] := wrreal;            map[wr, chars] := wrchar;
      map[wr, arrays] := wrst;             map[wr, bools] := wrbool;
      map[wr, strings] := wrxstr;          map[rd, ints] := rdint;
      map[rd, reals] := rdreal;            map[rd, chars] := rdchar;
      map[rd, arrays] := rdst;             map[rd, strings] := rdxstr;
      map[addrop, opaques] := addr;        map[addrop, words] := addr;
      map[addrop, bytes] := addr;          map[addrop, ptrs] := addr;
      map[addrop, fptrs] := addr;          map[addrop, procs] := addr;
      map[negop, scalars] := negint;       map[negop, ints] := negint;
      map[negop, ptrs] := negint;          map[negop, reals] := negreal;
      map[sysfn, ints] := sysfnint;        map[sysfn, chars] := sysfnint;
      map[sysfn, bools] := sysfnint;       map[sysfn, scalars] := sysfnint;
      map[sysfn, reals] := sysfnreal;      map[sysfn, ptrs] := sysfnint;
      map[sysfn, strings] := sysfnstring;  map[float, ints] := flt;
      map[float1, ints] := flt;            map[float_double, ints] := flt;
      map[real_to_dbl, reals] := cvtrd;    map[dbl_to_real, doubles] := cvtdr;
      map[definelazyop, files] := definelazy;
      map[setbinfileop, files] := setbinfile;
      map[setfileop, none] := setfile;
      map[closerangeop, none] := closerange;

      { Map entries for doubles }

      map[moveop, doubles] := movreal;     map[movelit, doubles] := movlitreal;
      map[plusop, doubles] := addreal;     map[minusop, doubles] := subreal;
      map[mulop, doubles] := mulreal;      map[slashop, doubles] := divreal;
      map[eqop, doubles] := eqreal;        map[neqop, doubles] := neqreal;
      map[lssop, doubles] := lssreal;      map[gtrop, doubles] := gtrreal;
      map[geqop, doubles] := geqreal;      map[leqop, doubles] := leqreal;
      map[eqlit, doubles] := eqlitreal;    map[neqlit, doubles] := neqlitreal;
      map[lsslit, doubles] := lsslitreal;  map[gtrlit, doubles] := gtrlitreal;
      map[leqlit, doubles] := leqlitreal;  map[geqlit, doubles] := geqlitreal;
      map[pushaddr, doubles] := pshaddr;
      map[pushlitvalue, doubles] := pshlitreal;
      map[wr, doubles] := wrreal;          map[rd, doubles] := rdreal;
      map[negop, doubles] := negreal;      map[sysfn, doubles] := sysfnreal;

      for i := subranges to none do map[loopholeop, i] := loopholefn;
      for i := subranges to none do map[dummyargop, i] := dummyarg;
      for i := subranges to none do map[dummyarg2op, i] := dummyarg2;
    end; {[s=1] map3}


  procedure map4;

{ Initialize operators used for C
}

    var
      i: types; {induction var}


    begin {[s=2] Format two assignments per line}
      map[addeqop, ints] := addint;        map[addeqop, reals] := addreal;
      map[addeqop, ptrs] := addptr;        map[andeqop, ints] := andint;
      map[addeqop, scalars] := addint;     map[castfptrop, ints] := castintfptr;
      map[castfptrop, ptrs] := castintfptr; {***hmmm...***}
      map[castintop, ptrs] := castptrint;  map[castintop, ints] := castint;
      map[castintop, fptrs] := castfptrint;
      map[castintop, reals] := castrealint;
      map[castptrop, ints] := castintptr;  map[castptrop, ptrs] := castptr;
      map[castrealop, ints] := flt;        map[castrealop, reals] := castreal;
      map[compop, ints] := compint;        map[daddop, none] := dataadd;
      map[daddrop, none] := dataaddr;      map[dendop, none] := dataend;
      map[dfaddrop, none] := datafaddr;    map[dfieldop, none] := datafield;
      map[dfillop, none] := datafill;      map[dintop, none] := dataint;
      map[diveqop, ints] := getquo;        map[diveqop, reals] := divreal;
      map[diveqop, scalars] := getquo;     map[drealop, none] := datareal;
      map[dstartop, none] := datastart;    map[dstoreop, none] := datastore;
      map[dstructop, none] := datastruct;  map[dsubop, none] := datasub;
      map[extop, none] := bad;             map[fptrop, ints] := dofptr;
      map[modeqop, ints] := getrem;        map[modeqop, scalars] := getrem;
      map[muleqop, ints] := mulint;        map[muleqop, reals] := mulreal;
      map[muleqop, scalars] := mulint;     map[oreqop, scalars] := orint;
      map[oreqop, ints] := orint;          map[postincop, ints] := postint;
      map[postincop, scalars] := postint;  map[postincop, reals] := postreal;
      map[postincop, ptrs] := postptr;     map[preincop, ptrs] := preincptr;
      map[pushfptr, fptrs] := pshfptr;     map[pushret, ptrs] := pshretptr;
      map[jumpvfuncop, none] := jumpvfunc; map[jumpvfuncop, ints] := jumpvfunc;
      map[returnop, ints] := returnint;    map[returnop, reals] := returnreal;
      map[returnop, ptrs] := returnptr;    map[returnop, fptrs] := returnfptr;
      map[returnop, fields] := returnstruct;
      map[returnop, stringliterals] := returnstruct;
      map[returnop, chars] := returnint;   map[returnop, bools] := returnint;
      map[returnop, scalars] := returnint;
      map[returnop, strings] := returnstruct;
      map[returnop, words] := returnint;   map[returnop, bytes] := returnint;
      map[returnop, procs] := returnfptr;  map[returnop, doubles] := returnreal;
      map[returnop, arrays] := returnstruct;
      map[returnop, sets] := returnstruct; map[returnop, opaques] := returnptr;
      map[shiftleqop, scalars] := shiftlint;
      map[shiftleqop, ints] := shiftlint;  map[shiftreqop, ints] := shiftrint;
      map[shiftreqop, scalars] := shiftrint;
      map[shiftrop, scalars] := shiftrint; map[shiftrop, ints] := shiftrint;
      map[subeqop, ints] := subint;        map[subeqop, scalars] := subint;
      map[subeqop, reals] := subreal;      map[subeqop, ptrs] := subptr;
      map[tempop, ints] := regtemp;        map[tempop, scalars] := regtemp;
      map[tempop, ptrs] := ptrtemp;        map[tempop, reals] := realtemp;
      map[tempop, fptrs] := ptrtemp;       map[xoreqop, scalars] := xorint;
      map[xoreqop, ints] := xorint;        map[xorop, ints] := xorint;
      map[xorop, scalars] := xorint;
    end; {[s=1] map4}


  procedure cmap;

{ Initialize the cast map
}


    begin
      castmap[ints, ints] := castint;
      castmap[ints, ptrs] := castptrint;
      castmap[ints, fptrs] := castfptrint;
      castmap[ints, reals] := castrealint;
      castmap[ptrs, ints] := castintptr;
      castmap[fptrs, ints] := castintfptr;
      castmap[reals, ints] := flt;
      castmap[reals, reals] := castreal;
    end;


  function rdup(i: shortint): shortint;
  { Round size.
  }


    begin {rdup}
      case hostmachine of
        mc68000, iapx86, i80386:
          if odd(i) then rdup := i + 1
          else rdup := i;
        otherwise rdup := i;
        end;
    end {rdup} ;


  begin {inittravrs}

    lasttravrslabel := 1;

    for o := endexpr to xorop do
      for t := subranges to none do map[o, t] := bad;
    for t := subranges to none do
      for t1 := subranges to none do castmap[t, t1] := bad;

    map1;
    map2;
    map3;
    map4;

    cmap;

    reset(locals);
    reset(tempfiletwo);

    nextpseudofile := 0;
    nextintcode := 0;
    laststmt := 1;
    walkdepth := 0;
    hoistone := 0;
    hoisttwo := 0;
    maxnodes := 0;
    for p := 1 to proctabletop do
      if newtravrsinterface then
        new_proctable[p div (pts + 1)]^[p mod (pts + 1)].referenced := false
      else proctable[p].referenced := false;
    anynonlocalgotos := false;
    emitpseudo := false;
  end {inittravrs} ;



{ Intermediate File Handling -

  Both the Intermediate file generated by analys and the pseudo-code
  file written for the code generator are implemented as files of
  arrays of the basic file type.  There are global variables
  "nextpseudofile" and "nextintcode" which serve as indices into
  these arrays.  For instance, the current intermediate file element
  is referenced as intfile^[nextintcode].

  Embedded switches are kept in a table ("switches") and are synchronized
  with the intermediate file by a count of elements.

  As the intermediate file is read, the count is compared to that of
  the next switch in the table and the switchcounters set accordingly.
  At the same time, the element count in "switches" is updated to the
  output element count.  Note that in this pass this will effectively
  group all switches at the start of the procedure in which they
  occur, as the pseudocode is not generated until the entire procedure
  has been read in.

  DRB: for free pascal (and later the real thing perhaps) the file from
  analys is just passed a stream of records rather than packed into
  bytes.
}

function getintfileint: unsignedint;

{ Returns an integer passed in the intermediate file as a pair of bytes.
}

  var
    { This fudges an integer into bytes.  The constant "32" is }
    { simply a large enough number to include all probable systems. }
    fudge:
      record
        case boolean of
          true: (int: unsignedint);
          false: (byte: packed array [1..32] of hostfilebyte);
      end;

    j: 1..32; {induction var}

  begin {getintfileint}
    fudge.int := tempfilebuf.b;
    if fudge.int = hostfilelim then
      for j := 1 to hostintsize * hostfileunits do
        begin
        read(tempfiletwo, tempfilebuf);
        fudge.byte[j] := tempfilebuf.b;
        end;
    getintfileint := fudge.int;
  end {getintfileint} ;

procedure getintreal(var val: realarray);

{ Get a real value from the intermediate file into val
}

  var
    i: 1..32;
    s: addressrange; {size read so far}
    kludge:
      packed record
        case boolean of
          true: (r: realarray);
          false: (i: packed array [1..32] of integer; );
      end;


  begin
    s := 0;
    i := 1;
    while s < maxrealwords do
      begin
      read(tempfiletwo, tempfilebuf);
      kludge.i[i] := getintfileint;
      i := i + 1;
      s := s + sizeof(integer);
      end;
    val := kludge.r;
  end;


procedure buildrdfo(current, previous: basicblockptr);
{
    Purpose:
    link the block together in reverse of the dfo list.

    Inputs:
      current : ptr to current basic block as we descend dfo list.
      previous : ptr to previous basic block as we descend dfo list.

    Outputs:
      none.

    Algorithm:
      Simply mark rdfo of current as previous and recurses if possible.

    Sideeffects:
      basic block is modified.

    Last Modified: 9/9/85

}


  begin {buildrdfo}
    current^.visited := visitstate;
    current^.rdfolist := previous;
    if current^.dfolist <> nil then buildrdfo(current^.dfolist, current);
  end; {buildrdfo}


procedure searchdfo(rootnode: basicblockptr;
                    var prevblock: basicblockptr);
{
    Purpose:
      Walk the list of basic block in depth first order.

    Inputs:
      rootnode : ptr to current block to visit.

    Outputs:
      prevblock : set to rootnode on exit

    Algorithm:
      Set current block as visited then recurse on each of the successors to
      this block.

    Sideeffects:
      dfolist and visited fields are modified.

    Last Modified: 6/27/85

}

  var
    succnode: linkptr; { successor links }


  begin {searchdfo}
    rootnode^.visited := visitstate;
    succnode := rootnode^.successor;
    while succnode <> nil do
      begin
      if succnode^.suc^.visited <> visitstate then
        searchdfo(succnode^.suc, prevblock);
      succnode := succnode^.snext;
      end;
    rootnode^.dfolist := prevblock;
    prevblock := rootnode;
  end; {searchdfo}


procedure enterloop(blkid: basicblockptr);
{
    Purpose:
      Set up to calculate loop dominators and monitor reads and writes in
      the loop.

    Inputs:
      blkid : ptr to the block heading the loop

    Outputs:
      initializes loop context.

    Algorithm:
      Simple initialization.

    Sideeffects:
      loopfactor, loopdepth, loopoverflow, and loopstack changed.

    Last Modified: 9/9/85

}

  var
    i: levelindex; { induction var }


  begin {enterloop}
    loopfactor := loopfactor + 5;
    if loopdepth = maxloopdepth then
      begin
      loopoverflow := loopoverflow + 1;
      blkid^.deadloop := true;
      end
    else
      begin
      loopdepth := loopdepth + 1;
      with loopstack[loopdepth] do
        begin
        loopblock := blkid;
        reads := 0;
        writes := 0;
        lastwrite := 0;
        for i := 0 to maxlevel do deadlevels[i] := false;
        fonmin := foncount;
        end;
      end;
  end {enterloop} ;


procedure exitloop;
{
    Purpose:
      Set up to calculate loop dominators, adjust local var's lifetimes and
      join write chain to any outer loop.

    Inputs:
      none

    Outputs:
      restores previous loops context

    Algorithm:
      Adjusts the lifetime of any var mentioned in the loop to encompass
      the entire loop. Actually by making every var reach the bottom their
      lifetimes will conflict producing the desired result.
      Any write's taking place in this loop are tacked onto the end of the
      write's of the enclosing (if any) loop.

    Sideeffects:
      loopdepth, loopoverflow, loopfactor changed.

    Last Modified: 7/22/85

}

  var
    ptr: nodeptr; { for access to nodes }
    bptr: basicblockptr; { copy of loopblock ptr }
    i: reghashindex; { induction var }


  begin {exitloop}
    { fix the lifetimes of vars mentioned in the loop }
    for i := 0 to regtablelimit do
      begin
      with regvars[i], varlife do
        begin
        if (worth > 0) and ((fonmin >= loopstack[loopdepth].fonmin) or
           (fonmax >= loopstack[loopdepth].fonmin)) then
          begin
          lonmax := lastnode;
          { never let fonmax decrease!}
          if foncount > fonmax then fonmax := foncount;
          end;
        end;
      end;
    loopfactor := loopfactor - 5;
    if loopoverflow > 0 then
      begin
      loopoverflow := loopoverflow - 1;
      end
    else
      begin
      with loopstack[loopdepth] do
        begin
        bptr := loopblock;
        bptr^.reads := reads;
        bptr^.writes := writes;
        bptr^.lastwrite := lastwrite;
        bptr^.deadlevels := deadlevels;
        end;
      loopdepth := loopdepth - 1;
      { now hook inner loops writes to this loop }
      if (loopdepth > 0) and (bptr^.lastwrite <> 0) then
        begin
        if bigcompilerversion then ptr := @(bignodetable[bptr^.lastwrite]);
        with loopstack[loopdepth] do
          begin
          ptr^.looplink := writes;
          writes := bptr^.writes;
          if lastwrite = 0 then lastwrite := bptr^.lastwrite;
          end;
        end;
      end;
  end {exitloop} ;


{ Initialization data is passed in the intermediate file as a series of
  operators.  Such operators can appear in thd midst of an expression,
  or they can be preceeded by a "begdata" statement and appear outside
  of a statement or even a block body.  They do not cause anything to
  be placed in the tree, but generate pseudo-ops directly.
}


procedure take_data_op;

{ Take a data operator and generate output code.
}

  var
    this_op: operatortype; {current operator}
    len, op1, op2: integer; {operands}
    realval: realarray; {a value if it's a real}


  begin
    this_op := tempfilebuf.o;
    if this_op = drealop then
      begin
      read(tempfiletwo, tempfilebuf);
      len := getintfileint;
      getintreal(realval);
      genrealop(map[drealop, none], len, 0, 0, 0, realval);
      end
    else
      begin
      len := 0;
      op1 := 0;
      op2 := 0;
      case this_op of
        daddop, dsubop, dstoreop, dendop: {nothing} ;
        daddrop:
          begin
          read(tempfiletwo, tempfilebuf);
          len := getintfileint;
          read(tempfiletwo, tempfilebuf);
          op1 := getintfileint;
          read(tempfiletwo, tempfilebuf);
          op2 := getintfileint;
          end;
        dfaddrop, dintop, dstructop:
          begin
          read(tempfiletwo, tempfilebuf);
          len := getintfileint;
          read(tempfiletwo, tempfilebuf);
          op1 := getintfileint;
          end;
        dstartop, dfieldop:
          begin
          read(tempfiletwo, tempfilebuf);
          op1 := getintfileint;
          read(tempfiletwo, tempfilebuf);
          op2 := getintfileint;
          end;
        dfillop:
          begin
          read(tempfiletwo, tempfilebuf);
          len := getintfileint;
          end;
        end;
      genpseudo(map[this_op, none], len, 0, 0, 0, op1, op2, 0);
      if newtravrsinterface then
        begin
        if this_op = dfaddrop then
          new_proctable[op1 div (pts + 1)]^[op1 mod (pts +
           1)].referenced := true
        end
      else if this_op = dfaddrop then proctable[op1].referenced := true;
      end;
  end;


procedure passdata;

{ Called when a "begdata" statement is found.  It passes data statements
  until it finds an "endexpr" operator
}


  begin
    read(tempfiletwo, tempfilebuf);
    while tempfilebuf.o <> endexpr do
      begin
      take_data_op;
      read(tempfiletwo, tempfilebuf);
      end;
    read(tempfiletwo, tempfilebuf); {skip the endexpr}
  end; {passdata}


{ Build the statement tree for a procedure or function.
  This procedure contains all of the code to build a statement tree.
  As the tree is being built, all common subexpressions are detected
  and noted so that "walk" generates pseudocode for the common
  part only once.  This can be done because the pascal control structures
  provide a disciplined flow of data which avoids the need for elaborate
  flow tracing algorithms.  In the rare case when a "goto" is used, it
  simply clears all common subexpressions at the label and turns of lifetime
  analysis.

  The result is a basic block tree in core, with statement and expression
  trees in the virtual node structure.
}


procedure build;

{ Build a basic block tree for a procedure or function.

  This procedure itself actually does very little of the building,
  it uses internal procedures to do this.  This procedure itself
  initializes the block header, calls "buildstmtlist" to build the
  block body, and reads in temp data at the end of the block.

  Dead code elimination is much complicated by the addition of the
  C language, which allows jumps into structures.
}

  type
    locallabelptr = ^locallabeltype;
    locallabeltype =
      record
        block: basicblockptr; { basic block defining this pascal label }
        labelno: labelrange; { label value }
        link: locallabelptr; { predecessor chain }
      end;

    loop_descriptor = ^loop_data;
    loop_data = {holds data on loop nesting}
      record
        outer: loop_descriptor; {outer case, if any}
        header: nodeindex; {the header statement}
        cont_block: basicblockptr; {where to continue}
        break_block: basicblockptr; {where to break}
        break_found: boolean; {we found a break}
        cont_found: boolean; {we found a continue}
        looploop: boolean; {we are a "loop" loop, not "repeat" loop etc}
      end;

    case_descriptor = ^case_data;
    case_data =
      record
        outer: case_descriptor; {outer case, if any}
        casetopblock: basicblockptr; {block containing the selector}
        tailblock: basicblockptr; {the block following the case exit}
        casetopstmt: nodeindex; {the casehdr}
        caseexpr: nodeindex; {the expression for this case}
        contextlev: natural; {context level of the case controlled stat}
        loopd: natural; {loop depth of the case controlled stat}
        firstorder: nodeindex; {first node in ordered chain}
        lastorder: nodeindex; {last node in ordered chain}
        highlabel, lowlabel: integer; {for optimizing label access}
        lastlab: nodeindex; {last label allocated (inverse text order)}
        firstsplit: nodeindex; {the first case group we have built}
        splitcount: integer; {the number of groups}
        removing: boolean; {we are removing code}
        constvalue: integer; {the selector value if removing}
        found: boolean; {found a label in this group with value constvalue}
        ever_found: boolean; {we ever found one}
        casedef_found: boolean; {found a default label in this group}
        otherflow: boolean; {there is other flow into the current node}
        saveminfon: integer; {fon before statement list}
        savemaxfon: integer; {fon after statement list}
        old_swbreak_found: boolean; {save the flag}
        old_caselab_found: boolean; {in fact, two flags}
        last_dead: boolean; {the last case was dead}
        entry_dead: boolean; {case was dead on entry}
        start_deadcount: natural; {starting deadcount}
        lab_found: boolean; {we found a label in the code}
      end;

    dead_log = ^dead_element;
    dead_element =
      record
        next: dead_log; {next level of interest}
        level: natural; {level which was live}
      end;

  var
    locallabels: locallabelptr; { ptr to local label chain }
    templink: locallabelptr; { for disposing the local label links }
    i: integer; {induction var for reading temps}
    temp: nodeindex; { place holder }
    lastblock: basicblockptr; { most recent block added to dfo chain }
    currentblock: basicblockptr; { current basic block }
    retblock: basicblockptr; {return block for C programs}
    currentlaststmt: nodeindex; { index of last statement in this block}
    this_loop: loop_descriptor; {Current innermost loop}
    this_case: case_descriptor; {descriptor of current case statement}
    call_depth: integer;
    cond_depth: integer;

    deadcount: natural; {count of dead code levels}
    deadcode: boolean; {code is actually dead}
    gotodead: natural; {count of dead code due to goto's}
    dead_level: dead_log; {last level which was enlivened}
    swbreak_found: boolean; {we found a switch break}
    caselab_found: boolean; {we found a case label}
    b: basicblockptr; {for scanning the blocks}


{ Dead code elimination -

  In Pascal dead code can be eliminated by a simple count of dead code
  levels.  In C, which allows jumps into structured constructs, the
  bookkeeping is more complicated.  Such a jump can suddenly "enliven"
  dead code.

  To keep track of this we separate the dead code flag from the count of
  dead levels and turn on code again whenever we have a label (C only.)
  Code will be live from there until deadcount is zero.  Suppose,
  however, that we have some inner dead code, which increments deadcount
  after the label.  In this case we turn off code generation, but log
  this level so we can turn it on again when we hit it.  This is probably
  a rare occurance, so we allocated it on the heap rather than use an
  array or some other more efficient method.

  We would also like to include breaks and goto's in the general mechanism,
  especially since the C switch statement requires that we remember
  about them anyway.  We do this by logging the dead code level at
  the start of each structured statement (and the block, for that matter),
  incrementing the deadcount when a break is found, and decrementing
  it at the end of a block if the deadcount exceeds the saved count.

  This scheme works for everything but switch breaks which must be
  turned on by case labels.  The problem is that the break (and the
  label) may be improperly nested in other structured statements.
  We handle this with a special "switchbreak" flag, which must,
  of course be stacked in the switch descriptor.  This flag is set only
  when the context level of the break is the same as that of the switch.
  It's only in this situation that there is no structured statement to
  turn things on.  We also provide a flag which says that a case label
  was detected, and on exit from a level, if both flags are set they
  are turned off and the deadcount is decremented.

  This algorithm is incapsulated in the routine "dead_exit".
}


  procedure incr_deadcount;

{ Increment deadcount.  This always turns off code generation, and possibly
  logs a turn-on point.
}

    var
      d: dead_log; {for creating a log entry}


    begin
      if not deadcode and (deadcount > 0) then
        begin
        new(d);
        d^.next := dead_level;
        d^.level := deadcount;
        dead_level := d;
        end;
      deadcount := deadcount + 1;
      deadcode := true;
    end; {incr_deadcount}


  procedure decr_deadcount;

{ Decrement deadcount.  This turns on code generation if deadcount becomes
  zero or if it matches a previously logged level.
}

    var
      d: dead_log; {for disposing of a log entry}


    begin
      deadcount := deadcount - 1;
      if dead_level <> nil then
        begin
        if dead_level^.level = deadcount then
          begin
          deadcode := false;
          d := dead_level;
          dead_level := d^.next;
          dispose(d);
          end;
        end
      else if deadcount = 0 then deadcode := false;
    end; {decr_deadcount}


  procedure dead_exit(start: natural {starting dead count} );

{ This routine should be called at the end of each branch in a
  structured statement.  The parameter is the value of deadcount
  at the start of that expression.  All local adjustments of deadcount
  must be done by the time this is called.
}


    begin
      if deadcount > start then
        begin
        gotodead := gotodead - 1;
        decr_deadcount;
        end;
      if swbreak_found and caselab_found then decr_deadcount;
      swbreak_found := false;
      caselab_found := false;
    end;



  function bumpvarcount(varlev: levelindex; {level of var}
                        varisparam: boolean; {true if var is a parameter}
                        varoffset: addressrange {offset of var} ): boolean;

{ bump the useage count of a register candidate variable.
}

    var
      i: reghashindex; { hash value }


    begin {bumpvarcount}
      { if this is a register candidate, do lots of stuff }
      bumpvarcount := false;
      if varlev = level then
        begin
          { This hashes the variable's offset.  Really should be a
            function call.  However, it would be called in several
            high bandwidth places, and would produce an unneeded
            speed penalty in this phase.  This code is replicated
            in doreference, killasreg, initbuild and walk:indxnode.
          }
        i := (varoffset div targetintsize) mod (regtablelimit + 1);
        while ((regvars[i].offset <> varoffset) or
              (regvars[i].parameter <> varisparam)) and
              (regvars[i].worth >= 0) do
          i := (i + 1) mod (regtablelimit + 1);
        with regvars[i], varlife do
          begin
          if worth >= 0 then
            begin
            { a definition }
            bumpvarcount := true;
            worth := worth + loopfactor;
            { set lifetime bounds }
            if lonmin = 0 then lonmin := laststmtnode;
            if laststmtnode > lonmax then lonmax := laststmtnode;
            if foncount < fonmin then fonmin := foncount;
            if foncount > fonmax then fonmax := foncount;
            end;
          end; {with}
        end;
    end {bumpvarcount} ;


  procedure dodefine(varp: nodeindex);
{
    Purpose:
      If within a loop, mark the var described by varp as written. Also for
      a local variable update it's reference count and lifetime.

    Inputs:
      varp : index of a node describing some type of var.

    Outputs:
      none.

    Algorithm:
      If in a loop:
       If procedure call has not killed all var's at this level previously,
       search the read list and remove this var, if it is found.  Then link
       this node into this loop's write list.
      If a local var, update refcount and lifetime fields.

    Sideeffects:
      as described.

    Last modified: 2/25/87 (Rick)

}
   { add a new definition of a simple var located at varoffset at local level }

    var
      ptr, ptr1: nodeptr; { for access to bit map nodes }
      varlev: levelindex; { varaible level }
      varoffset: addressrange; { location at varlev }
      varisparam: boolean; { true if variable is a parameter }
      now, prev: nodeindex; { for walking read chain }
      found: boolean; { loop exit flag }


    begin {dodefine}
      if bigcompilerversion then ptr := @(bignodetable[varp]);
      varlev := ptr^.oprnds[1];
      varoffset := ptr^.oprnds[2];
      if bigcompilerversion then ptr1 := @(bignodetable[ptr^.oprnds[3]]);

      if ptr1^.action = copy then
        if bigcompilerversion then ptr1 := @(bignodetable[ptr1^.directlink]);

      varisparam := (ptr1^.oprnds[1] = localparamnode);

      ptr^.invariant := false;
      ptr^.regcandidate := bumpvarcount(varlev, varisparam, varoffset);

      { if in a loop, add this to the writes for the loop, and kill the reads }

      if loopdepth > 0 then
        begin

        { if procedure call has killed off all reads, it's easy }

        if not loopstack[loopdepth].deadlevels[varlev] then
          begin
          with loopstack[loopdepth] do
            begin
            if ptr^.looplink <> 0 then
              writeln('write looplink <> 0 var ', varp: 1, ' block ', blockref:
                      1);
            ptr^.looplink := writes;
            writes := varp;
            if lastwrite = 0 then lastwrite := varp;

            { on this level, kill any reads of this var }

            prev := 0;
            now := reads;
            while (now <> 0) do
              begin
              if bigcompilerversion then ptr := @(bignodetable[now]);
              if varoffset = ptr^.oprnds[2] then
                found := (varlev = ptr^.oprnds[1])
              else found := false;
              if found then
                begin
                if not bigcompilerversion then blocksin[1].written := true;
                ptr^.invariant := false;
                if prev <> 0 then
                  begin
                  if bigcompilerversion then ptr1 := @(bignodetable[prev]);
                  ptr1^.looplink := ptr^.looplink;
                  end
                else reads := ptr^.looplink;
                now := ptr^.looplink;
                { isolate the node }
                ptr^.looplink := 0;
                end
              else
                begin
                prev := now;
                now := ptr^.looplink;
                end;
              end; {while}
            end; {with}
          end;
        end;
    end; {dodefine}


  procedure doreference(varp: nodeindex);
{
    Purpose:
      If within a loop, mark the var described by varp as read, if not already
      marked as written or dead by procedure call.  Also for a local variable,
      update it's reference count and lifetime.

    Inputs:
      varp : index of a node describing some type of var.

    Outputs:
      none.

    Algorithm:
      If in a loop:
       If procedure call has not killed all var's at this level previously,
       search the write list.  If this var is not found, then link
       this node into this loop's read list.
      If a local var, update refcount and lifetime fields.

    Sideeffects:
      as described.

    Last modified: 2/25/87 (Rick)

}

    var
      i: reghashindex; { hash value }
      j: nodeindex; { for walking read/write chains }
      found: boolean; { loop exit flag }
      ptr, ptr1: nodeptr; { for access to nodes }
      varlev: levelindex; { variable level }
      varoffset: addressrange; { location at varlev }
      varisparam: boolean; { true if variable is a parameter }


    begin {doreference}

      if bigcompilerversion then ptr := @(bignodetable[varp]);
      varlev := ptr^.oprnds[1];
      varoffset := ptr^.oprnds[2];

      if bigcompilerversion then ptr1 := @(bignodetable[ptr^.oprnds[3]]);
      if ptr1^.action = copy then
        if bigcompilerversion then ptr1 := @(bignodetable[ptr1^.directlink]);

      varisparam := (ptr1^.oprnds[1] = localparamnode);

      ptr^.regcandidate := bumpvarcount(varlev, varisparam, varoffset);

      { if in a loop, determine if modified in it yet }
        { If we have overflowed loopstack, then since invariant is
          initialized to false by default, all variables inside deeply
          nested loops (except forloop induction vars) will be marked
          as not invariant, which is what we want.

          NOTE: we must ignore forloop induction vars since they exist
          across loops and we can easily wind up building a circular
          list if references exist in multiple loops. This doesn't hurt
          since for loops are recognized as invariant by a different process.

        }
      { if already marked invariant, can't be written, is cse }

      if (loopdepth > 0) and (loopoverflow = 0) and not ptr^.invariant then
        begin

        { eliminate operands we are sure are written quickly.
        written := loopstack[loopdepth].deadlevels[varlev] or  ptr^.target;
        }

        if not (loopstack[loopdepth].deadlevels[varlev] or ptr^.target) then
          begin
          { must check the write list }
          j := loopstack[loopdepth].writes;
          found := false;
          while (j <> 0) and (not found) do
            begin
            if bigcompilerversion then ptr := @(bignodetable[j]);
            if varoffset = ptr^.oprnds[2] then
              found := (varlev = ptr^.oprnds[1])
            else found := false;
            j := ptr^.looplink;
            end;
          if not found then
            begin

            { Add it to the reads for this level, if not there already.
              Since this is the only place that sets invariant to true,
              if its true now this is a common subexpression and var
              is already linked in.
            }

            if bigcompilerversion then ptr := @(bignodetable[varp]);
            if not ptr^.invariant then
              begin
              ptr^.invariant := true;
              ptr^.looplink := loopstack[loopdepth].reads;
              loopstack[loopdepth].reads := varp;
              end;
            end;
          end; {must check }
        end;
    end; {doreference}


  procedure loopkill(lower, upper: levelindex);
{
    Purpose:
      Kill the reads of any loop read that is within the destructive
      power of the levels lower..upper.

    Inputs:
      lower : lowest level var that may be destroyed.
      upper : highest level var that may be destroyed.

    Outputs:
      none.

    Algorithm:
      Sets the dead levels for all levels in the loop. Then
      removes any read from loops that match the level bounds.

    Sideeffects:
      many.

    Last Modified: 7/26/85

}

    var
      now, prev: nodeindex; { for walking looplink of reads }
      ptr, ptr1: nodeptr; { for access to nodes }
      i: 1..maxloopdepth; {induction var }
      varlev: levelindex; { lex level of var }
      l: levelindex; { induction var }


    begin {loopkill}
      for i := 1 to loopdepth do
        begin
        with loopstack[i] do
          begin
          { first set the bounds }
          for l := lower to upper do deadlevels[l] := true;
        {
          Now kill all the reads that are already present in the loop
          that are within bounds.
        }
          { on this level, kill any reads of this var }
          prev := 0;
          now := reads;
          while now <> 0 do
            begin
            if bigcompilerversion then ptr := @(bignodetable[now]);
            varlev := ptr^.oprnds[1];

            if (varlev <= upper) and (varlev >= lower) then
              begin
              if not bigcompilerversion then blocksin[1].written := true;
              ptr^.invariant := false;
              if prev <> 0 then
                begin
                if bigcompilerversion then ptr1 := @(bignodetable[prev]);
                ptr1^.looplink := ptr^.looplink;
                end
              else reads := ptr^.looplink;
              now := ptr^.looplink;
              { isolate the node }
              ptr^.looplink := 0;
              end
            else
              begin
              prev := now;
              now := ptr^.looplink;
              end;
            end;
          end;
        end;
    end {loopkill} ;


  procedure killasreg(varp: nodeindex);

{   Purpose:
      Make a variable ineligible for register allocation.

    Inputs:
      varp: index of varop to be made ineligible.

    Outputs:
      none.

    Algorithm:
      If level is locallevel, hash the offset, find the
      variable in the table, and invalidate it.

    Sideeffects:
      localvar table is modified.

    Last Modified: 9/25/86 (Rick)

}

    var
      i: reghashindex; {hash value}
      ptr, ptr1: nodeptr; {for access to bit map nodes}
      varisparam: boolean; {true if the var in question is a parameter}
      varoffset: addressrange; {location at varlev}
      now, prev: nodeindex; {for walking read chain}


    begin {killasreg}

      if bigcompilerversion then ptr := @(bignodetable[varp]);
      while ptr^.op = commaop do
        begin
        varp := ptr^.oprnds[2];
        if bigcompilerversion then ptr := @(bignodetable[varp]);
        end;

        { Verify that operand is a variable.  Pushaddr also takes
          structop, pushcvalue, call, unscall, callparam, unscallparam,
          etc., which are ok but ignored here.
        }

      if (ptr^.op in [varop, unsvarop, newvarop, newunsvarop]) and
         (ptr^.oprnds[1] = level) then
        begin
        blocksin[1].written := true;
        varoffset := ptr^.oprnds[2];
        if bigcompilerversion then ptr1 := @(bignodetable[ptr^.oprnds[3]]);

        if ptr1^.action = copy then
          if bigcompilerversion then
            ptr1 := @(bignodetable[ptr1^.directlink]);

        varisparam := (ptr1^.oprnds[1] = localparamnode);

          { This hashes the variable's offset.  Really should be a
            function call.  However, it would be called in several
            high bandwidth places, and would produce an unneeded
            speed penalty in this phase.  This code is replicated
            in doreference, dodefine, initbuild and walk:indxnode.
            }
        i := (varoffset div targetintsize) mod (regtablelimit + 1);
        while ((regvars[i].offset <> varoffset) or
              (regvars[i].parameter <> varisparam)) and
              (regvars[i].worth >= 0) do
          i := (i + 1) mod (regtablelimit + 1);
        if regvars[i].worth >= 0 then
          begin
          ptr^.regcandidate := false;
          regvars[i].registercandidate := false;
          end;
        end;
    end {killasreg} ;


  procedure addpredsuccs(predblock, succblock: basicblockptr);

{ Add block "succblock" to the successor chains of block predblock
 Add block "predblock" to the predeccessor chains of block succblock
}

    var
      newlink: linkptr; { ptr to new link block }


    begin
      if (predblock <> nil) and (succblock <> nil) then
        begin
        new(newlink);
        newlink^.snext := predblock^.successor;
        predblock^.successor := newlink;
        newlink^.suc := succblock;
        newlink^.pnext := succblock^.predeccessor;
        succblock^.predeccessor := newlink;
        newlink^.pre := predblock;
        end;
    end; {addpredsuccs}


  procedure newblock(var b: basicblockptr; {resulting block node}
                     predblock: basicblockptr; { predecessor block }
                     largeblock: boolean { true if loophdr is possible} );

{ Make a new basic block node. The fields are all given default values.
  Since this is a new context "firstblock" in this context level is
  set to point here. This is done so that preconditions can be hooked
  to the basic block header. Also the default action is to make this
  block the successor of currentblock and currentblock the predecessor
  of the new block.
}

    var
      l: levelindex; { induction var }


    begin
      new(b);
      { default is that code will dominate if context dominates }
      b^.dominates := context[contextsp].dominates;
      blockblocks := blockblocks + 1;
      currentblock := b;

      { now initialize to something reasonable ( re-init if dead ) }

      with b^ do
        begin
        isdead := deadcode and (removedeadcode in genset);
        visited := visitstate;
        precode := 0;
        beginstmt := 0;
        forcelabel := false;
        loophdr := false;
        joinop := false;
        saveop := false;
        restoreop := false;
        clearop := false;
        dfolist := nil;
        rdfolist := nil;
        successor := nil;
        predeccessor := nil;
        blocklabel := 0;
        if largeblock then
          begin
          willexecute := false;
          deadloop := false;
          looplabel := 0;
          reads := 0;
          writes := 0;
          lastwrite := 0;
          for l := 0 to maxlevel do deadlevels[l] := false;
          end;
        end; {with}

      if (predblock <> nil) then addpredsuccs(predblock, currentblock);
    end {newblock} ;


  procedure newstmt(var p: nodeindex; {resulting statement node}
                    s: stmthdrtype {type of node to make} );

{ Make a new statement node of type "s".  The fields are initialized
  appropriately.  If this is the first statement in a new context
  level, the pointer "prestmt" in the context record is set to it
  to provide a place to link preconditions for the statement sequence
  in this context.
}

    var
      ptr, ptr1: nodeptr; {used for access to node}


    begin {newstmt}
      if lastnode = tnodetablesize then compilerabort(manynodes)
      else
        begin
        lastnode := lastnode + 1;
        laststmtnode := lastnode;
        if lastnode > maxnodes then maxnodes := lastnode;
        p := lastnode;
        { if this is the first stmt for this basic block link it in }
        if currentblock^.beginstmt = 0 then
          begin
          if context[contextsp].firstblock = nil then
            context[contextsp].firstblock := currentblock;
          currentblock^.beginstmt := lastnode;
          currentlaststmt := lastnode;
          end
        else
          begin
          if bigcompilerversion then ptr := @(bignodetable[currentlaststmt]);
          ptr^.nextstmt := lastnode;
          currentlaststmt := lastnode;
          end;
        if bigcompilerversion then ptr := @(bignodetable[p]);
        with ptr^ do
          begin
          nodeform := stmtnode;
          srcfileindx := 0;
          nextstmt := 0;
          stmtkind := s;
          if s in
             [whilehdr, rpthdr, ifhdr, foruphdr, fordnhdr, withhdr, casehdr,
             loophdr, simplehdr, syscallhdr, gotohdr, cforhdr, loopbrkhdr,
             cswbrkhdr, loopconthdr, returnhdr] then
            begin

            if language = c then
              begin
              srcfileindx := 0;
              read(tempfiletwo, tempfilebuf);
              stmtno := getintfileint;
              end
            else
              begin
              read(tempfiletwo, tempfilebuf);
              srcfileindx := getintfileint;

            if newdebugger then
              begin
              read(tempfiletwo, tempfilebuf);
              stmtno := getintfileint;
              end
            else
              begin
              stmtno := laststmt;
              laststmt := laststmt + 1;
              end;

              { This little hack is needed if the entire procedure body is
                deadcoded out and if the first statement of the procedure
                has the source file index, then the index will be lost.
                If this is also the first procedure in the module then pma
                will have no filename to print.  Since we always pass the
                blkhdr this code will copy the srcfileindx up.  We only
                support changing source file between procedures, not in the
                middle, so the previous node should be is not a blkhdr.  If
                it is not just let it go.

                Don sez: this little hack has the effect of removing the
                file index passed with the first dummy statment used by
                the new debugger.  So I hacked it a little bit more.
                Would have been MUCH better if the analys/travrs interface
                had been changed so that the srcfileindex was just passed
                in the intcode for blkhdr.  Note the assignment I added
                for stmtno:  the little hack didn't work for newdebugger
                'cause walkblk only emits a genstmtbrk if stmtno <> 0.
                The check for 'simplehdr' should be sufficient because
                only structured statements can trigger dead code and if
                the first statement of a block is a simple statement, the
                entire body won't be removed.
              }
              if s <> simplehdr then
                begin
                if bigcompilerversion then ptr1 := @(bignodetable[p - 1]);
                if (ptr1^.nodeform = stmtnode) and (ptr1^.stmtkind = blkhdr)
                then
                  begin
                  ptr1^.srcfileindx := srcfileindx;
                  if newdebugger then ptr1^.stmtno := stmtno;
                  srcfileindx := 0;
                  end;
                end;
              end;

            read(tempfiletwo, tempfilebuf);
            textline := getintfileint;
            end;

          case s of
            blkhdr:
              begin
              if newdebugger then stmtno := 0
              else
                begin
                stmtno := laststmt;
                laststmt := laststmt + 1;
                end;

              textline := getintfileint;
              read(tempfiletwo, tempfilebuf);
              procref := getintfileint;
              blockref := procref;
              read(tempfiletwo, tempfilebuf);
              ps := getintfileint;
              read(tempfiletwo, tempfilebuf);
              bs := getintfileint;
              read(tempfiletwo, tempfilebuf);
              fileline := getintfileint;
              read(tempfiletwo, tempfilebuf);
              if newtravrsinterface then
                begin
                level := new_proctable[procref div (pts + 1)]^[procref mod
                         (pts + 1)].level;
                intlevelrefs := new_proctable[procref div (pts +
                                1)]^[procref mod (pts + 1)].intlevelrefs;
                end
              else
                begin
                level := proctable[procref].level;
                intlevelrefs := proctable[procref].intlevelrefs;
                end;
              end;
            casehdr:
              begin
              selector := 0;
              casedefptr := nil;
              elements := 0;
              joinblock := nil;
              lowestlabel := 0;
              highestlabel := 0;
              end;
            caselabhdr:
              begin
              caselabellow := 0;
              caselabelhigh := 0;
              stmtblock := nil;
              stmtlabel := 0;
              orderedlink := 0;
              end;
            whilehdr, rpthdr, ifhdr, foruphdr, fordnhdr, withhdr, simplehdr,
            syscallhdr, untilhdr, cforhdr, cforbothdr, nohdr:
              begin
              expr1 := 0;
              expr2 := 0;
              has_break := false;
              trueblock := nil;
              falseblock := nil;
              end;
            loopbrkhdr, loopconthdr, swbrkhdr, cswbrkhdr: targblock := nil;
            gotohdr, labelhdr:
              begin
              labelno := 0;
              nonlocalref := false;
              labellevel := 0;
              end;
            otherwise
            end {case}
          end; {else}
        end; {with}
    end {newstmt} ;


  procedure newexprnode(var n: nodeindex {resulting new node} );

{ Allocates a new expression node in the virtual node space and initializes
  its fields.
}

    var
      p: nodeptr; {used for access to node}


    begin
      if lastnode = tnodetablesize then compilerabort(manynodes)
      else
        begin
        lastnode := lastnode + 1;
        if lastnode > maxnodes then maxnodes := lastnode;
        n := lastnode;
        if bigcompilerversion then p := @(bignodetable[lastnode]);
        with p^ do
          begin
          {nice to use structured constant here }
          nodeform := exprnode;
          op := endexpr;
          form := none;
          action := visit;
          refcount := 0;
          copycount := 0;
          valid := false;
          mustinvalidate := false;
          join := false;
          target := false;
          relation := false;
          local := false;
          invariant := false;
          nodeoprnd[1] := false;
          nodeoprnd[2] := false;
          nodeoprnd[3] := false;
          cost := 0;
          prelink := 0;
          hoistedby := nil;
          looplink := 0;
          slink := 0;
          len := 0;
          hasvalue := false;
          ownvar := false;
          oprnds[1] := 0;
          oprnds[2] := 0;
          oprnds[3] := 0;
          oldlink := 0;
          end;
        end;
    end {newexprnode} ;


  function hash(op: operatortype; {operator of this node}
                i1, i2: integer {operand nodes} ): maphashindex;

{ Generate a hash function to speed search for identical nodes.
  It is set up so that all variables hash to the same value (0), so
  they can be searched easily for context changes.  For instance,
  all variables must be marked invalid when a label is encountered.

  This ignores the fact that the rval field overlays the operand fields.
  We simply take whatever happens to be there.  Since the values are
  initialized to zero before assigning to rval, the worse we can do
  is make the hash not as good.
}


    begin
      if op in [varop, unsvarop] then hash := 0
      else
        begin
        if modworks then hash := (ord(op) + i1 + i2) mod nodehashsize + 1
        else hash := ((ord(op) + i1 + i2) and 32767) mod nodehashsize + 1;
        end;
    end {hash} ;


  procedure initbuild;

{ Initialize the "build" procedure.  Called once before building each
  block body.  It resets the node counter "lastnode" to reuse nodes,
  initializes stack pointers, and clears context maps.
}

    var
      n: nodeindex; {dummy argument to newexprnode}
      i: shortint; {induction var for clearing opmap and virt mem}
      localvar: localvartype; { file read temp }
      ptr: nodeptr; { for access to node }
      j: reghashindex; { unsigned var for quicker mod }


    begin

      blockblocks := 0;
      thrashing := false;
      lastnode := - 1;
      laststmtnode := - 1;
      currentblock := nil;
      deadcount := 0;
      gotodead := 0;
      deadcode := false;
      dead_level := nil;
      swbreak_found := false;
      caselab_found := false;
      newexprnode(n);

      withsp := 0;
      forsp := 0;
      loopdepth := 0;
      loopoverflow := 0;
      contextsp := 2;
      overflowdepth := 0;

      this_loop := nil;
      this_case := nil;
      final_block_size := 0;

      with context[2] do
        begin
        for i := 0 to nodehashsize do opmap[i] := 0;
        searchlevel := 2;
        joinflag := false;
        dominates := true;
        firstblock := nil;
        end;

      with context[1] do
        begin
        opmap := context[2].opmap;
        searchlevel := 1;
        joinflag := false;
        dominates := false;
        firstblock := nil;
        end;
      shorteval := false;

      locallabels := nil;

      visitstate := false; { set initial state }

      { set option mask, do everything as default }
      genset := [firstgenopt..lastgenopt];

      { now remove some based on current switch value }
      if (switchcounters[debugging] > 0) or (switchcounters[profiling] > 0) or
         switcheverplus[targdebug] then
        begin
        genset := genset - [lifetimes, propagation, hoisting, removedeadcode,
                  subexpressions, tailmerging, bitops];
        end;

      { ***Note: "C" additions originally broke hoisting, thus they were
                 disabled for "C" until fixed.
      }

      if (targetmachine = iapx86) { or (language = c)} then
        genset := genset - [hoisting];

      { now override these options based upon command line }

      if switcheverplus[genmask] then
        if genoptmask < 0 then genset := genset + overrideset
        else genset := genset - overrideset;

      nowdebugging := (switchcounters[debugging] > 0) or
                      (switchcounters[profiling] > 0) or
                      switcheverplus[targdebug];
      nowwalking := (switchcounters[walkback] > 0);
      exit_stmtno := 0;

      { init the local var map }

      regvars[0].regid := 0;
      regvars[0].varlife.lonmin := 0;
      regvars[0].varlife.fonmin := 0;
      if lifetimes in genset then
        begin
        regvars[0].varlife.lonmax := 0;
        regvars[0].varlife.fonmin := shortmaxint;
        regvars[0].varlife.fonmax := 0;
        end
      else
        begin
        { no lifetimes set region to encompass entire block }
        regvars[0].varlife.lonmax := tnodetablesize;
        regvars[0].varlife.fonmin := 0;
        regvars[0].varlife.fonmax := shortmaxint;
        end;

      regvars[0].worth := - 1;
      regvars[0].registercandidate := false;

      for j := 1 to regtablelimit do
        begin
        regvars[j] := regvars[0];
        end;

      read(locals, localvar);
      while localvar.typ <> none do
        begin
          { This hashes the var's offset, really should be a function call.
            However it would be called in several high bandwidth places and
            places an unneeded speed penalty on this phase.
            This code is replicated in doreference, killasreg, dodefine
            and walk:indxnode.
          }
        j := (localvar.offset div targetintsize) mod (regtablelimit + 1);
        while regvars[j].worth >= 0 do j := (j + 1) mod (regtablelimit + 1);
        with regvars[j] do
          begin
          {figure out mapping from data type to register type }
          case targetmachine of
            vax, iapx86:
              begin
              registercandidate := true;
              regkind := genreg;
              end;
            i80386:
              begin
              registercandidate := true;
              if localvar.size = 1 then regkind := bytereg
              else regkind := genreg;
              end;
            mc68000:
              begin
              registercandidate := true;
              case localvar.typ of
                ptrs, fptrs: regkind := ptrreg;
                reals, doubles:
                  if switcheverplus[fpc68881] then regkind := realreg
                  else regkind := genreg;
                otherwise regkind := genreg;
                end {typ} ;
              end;
            ns32k:
              begin
              registercandidate := true;
              case localvar.typ of
                reals: regkind := realreg;
                otherwise regkind := genreg;
                end {typ} ;
              end;
            otherwise;
            end; {targetmachine}
          offset := localvar.offset;
          debugrecord := localvar.debugrecord;

          { currently, only C front-end supports register parameters }
          case language of
            pascal, modula2: parameter := false;
            c: parameter := localvar.is_param;
            end;

          { mark this spot as allocated }
          worth := 0;
          end;
        read(locals, localvar);
        end;
      foncount := 0;
      loopfactor := 1; {every ref equal 1 ref }
      irreducible := false;
      localparamnode := 0;
    end {initbuild} ;


  procedure addopmap(n: nodeindex; {node to add}
                     op: operatortype; {operator of that node}
                     hashvalue: maphashindex; {hash for node}
                     contextlevel: contextindex {context to add to} );

{ Add an operator to the opmap of the context specified by "contextlevel".
  Only those operators which can contribute to common subexpressions
  are added to the map.  Some are excluded (such as rd) because they
  have an important side-effect, while others are excluded because
  they are not useful.  The operator is included in the calling sequence
  to avoid a possible file access, only to discover that the node is
  not needed.
}

    var
      p: nodeptr; {use to access op chain items}


    begin
      if (op >= intop) then
        with context[contextlevel] do
          begin
          if bigcompilerversion then p := @(bignodetable[n]);
          p^.slink := opmap[hashvalue];
          { operators at contextlevel 1 are hoisted for free }
          if contextlevel = 1 then
            begin
            p^.prelink := p^.slink;
            p^.hoistedby := root;
            end;
          opmap[hashvalue] := n;
          end;
    end {addopmap} ;


  procedure savecontext;

{ Save the common expression context for entry into a new level of
  branching structure.  This is called on entry to an "if" or "case" to
  save the context for later restoration.  This allow each branch of
  the structure to start off with the same initial context.

  If contextsp = contextdepth, overflowdepth is incremented.  If not,
  a new level of the context stack is allocated with an initially clear
  opmap.  Each still valid expression has its "deepestvalid" field set
  to the new level, which allows the expressions to be reset to valid
  if they are invalidated at an inner level.  Since expressions are
  built bottom up (starting with the terminals), only variables need be
  marked.  This is simple to do because the hash function places all
  variables in opmap[0].
}

    var
      p: nodeptr; {used for access to nodes}
      i: shortint; {general purpose induction var}
      n: nodeindex; {used to trace list of nodes on opmap[0]}


    begin
      if contextsp = contextdepth then overflowdepth := overflowdepth + 1
      else
        begin
        contextsp := contextsp + 1;
        context[contextsp] := context[contextsp - 1];
        with context[contextsp] do
          begin
          firstblock := nil;
          joinflag := false;
          for i := 0 to nodehashsize do opmap[i] := 0;
          for i := searchlevel to contextsp do
            begin
            n := context[i].opmap[0];
            while n <> 0 do
              begin
              if bigcompilerversion then p := @(bignodetable[n]);
              with p^ do
                begin
                if valid then
                  begin
                  if not bigcompilerversion then blocksin[1].written := true;
                  deepestvalid := contextsp;
                  end;
                n := slink;
                end;
              end;
            end;
          end;
        end;
      { entering a new context, it will not run }
      context[contextsp].dominates := false;
    end {savecontext} ;


  procedure restorecontext;

{ Restore the context to the state it had prior to a "savecontext".
  This is called on exit from an inner level of statement nesting to
  restore the context to the state it had on entry to the level.  Any
  nodes which were invalidated within the inner level have their
  joinflag set so that they will be invalidated in a later join.

  Also, if "deepestvalid" is greater than the current level, the
  valid" flag is set on, and "deepestvalid is reset to the current
  level.

  If overflowdepth > 0, we have overflowed the context stack and cannot
  properly restore context.  In this case, all nodes active at the current
  level are simply destroyed.  This is implemented by clearing the
  hash table for the current level.
}

    var
      p: nodeptr; {used for access to nodes}
      i: shortint; {Induction var for context level scan}
      n: nodeindex; {used to trace nodes on opmap[0]}


    begin
      if overflowdepth > 0 then
        begin
        overflowdepth := overflowdepth - 1;
        { since we've lost track assume the worst }
        context[contextsp].dominates := false;
        for i := 0 to nodehashsize do context[contextdepth].opmap[i] := 0;
        end
      else
        begin
        contextsp := contextsp - 1;
        with context[contextsp] do
          begin
          for i := searchlevel to contextsp do
            begin
            n := context[i].opmap[0];
            while n <> 0 do
              begin
              if bigcompilerversion then p := @(bignodetable[n]);
              with p^ do
                begin
                if not bigcompilerversion then
                  blocksin[1].written := blocksin[1].written or not valid or
                                         (deepestvalid > contextsp);
                join := join or not valid;
                if deepestvalid > contextsp then
                  begin
                  deepestvalid := contextsp;
                  valid := true;
                  end;
                n := slink;
                end;
              end;
            end;
          end;
        end;
    end {restorecontext} ;


  procedure popcontext;

{ Used as a replacement for "restorecontext" when the restored
  values are no longer valid.  This is necessary because "break"
  can invalidate values from within a loop.  We pop the stack and
  leave variables invalidated rather than resetting them.
  we have to go through and reset deepestvalid, so we don't get
  to skip the scan.
}

    var
      p: nodeptr; {used for access to nodes}
      i: shortint; {Induction var for context level scan}
      n: nodeindex; {used to trace nodes on opmap[0]}


    begin
      if overflowdepth > 0 then
        begin
        overflowdepth := overflowdepth - 1;
        { since we've lost track assume the worst }
        context[contextsp].dominates := false;
        for i := 0 to nodehashsize do context[contextdepth].opmap[i] := 0;
        end
      else
        begin
        contextsp := contextsp - 1;
        with context[contextsp] do
          begin
          for i := searchlevel to contextsp do
            begin
            n := context[i].opmap[0];
            while n <> 0 do
              begin
              if bigcompilerversion then p := @(bignodetable[n]);
              with p^ do
                begin
                if not bigcompilerversion then
                  blocksin[1].written := blocksin[1].written or
                                         (deepestvalid > contextsp);
                join := join or not valid;
                if deepestvalid > contextsp then deepestvalid := contextsp;
                n := slink;
                end;
              end;
            end;
          end;
        end;
    end; {popcontext}


  procedure clearcontext;

{ Clear the context.  Used in situations when it is impossible to
  predict what expressions will be available, such as procedure call,
  label, or entry to a looping construct.

  There is an optimization used here which may not be obvious.  The
  variable "searchlevel" (local to a context) defines the minimum
  context level which will be searched for common expressions.
  By setting this to the current context, all prior contexts are
  effectively cleared without the labor of invalidating all of the
  nodes in them.  the "joinflag" in a context is used in a manner
  similar to  the individual "join" flags in expression nodes.  It
  says that the entire context should be invalidated when a "join"
  is executed.
}

    var
      i: shortint; {general purpose induction var}


    begin
      with context[contextsp] do
        begin
        for i := 0 to nodehashsize do opmap[i] := 0;
        if not (deadcode and (removedeadcode in genset)) then
          for i := 2 to contextsp - 1 do context[i].joinflag := true;
        searchlevel := contextsp;
        end;
    end {clearcontext} ;


  procedure joincontext;

{ Join a set of branching paths.  Called at the end of all paths of a
  branching construct to invalidate all nodes which have been
  invalidated on any path.  Such nodes are marked with a "join" flag
  which was set in "restorecontext" if the node had been invalidated.
  If "joinflag" is set for this context level, the entire level is
  invalid and is cleared at this point.

  Note that join flags are left set.  This is necessary because the
  contexts may be nested, and the nodes may be validated again by an
  outer "restorecontext.

  "Deepestvalid" is also adjusted to the current level if it is
  greater than the current level.
}

    var
      p: nodeptr; {used for access to nodes}
      i: shortint; {Induction var for context level scan}
      n: nodeindex; {used to trace nodes on opmap[0]}


    begin
      with context[contextsp] do
        begin
        if joinflag then
          begin
          searchlevel := contextsp;
          for i := 0 to nodehashsize do opmap[i] := 0;
          end
        else
          begin
          for i := searchlevel to contextsp do
            begin
            n := context[i].opmap[0];
            while n <> 0 do
              begin
              if bigcompilerversion then p := @(bignodetable[n]);
              with p^ do
                begin
                if not bigcompilerversion then
                  blocksin[1].written := blocksin[1].written or join or
                                         (deepestvalid > contextsp);
                if deepestvalid > contextsp then deepestvalid := contextsp;
                if join then valid := false;
                n := slink;
                end;
              end;
            end;
          end;
        end;
    end {joincontext} ;


  procedure pushloop(cblock: basicblockptr; {continue block}
                     bblock: basicblockptr {break block} );

{ Push a loop onto the list of currently active loops.  This is needed
  so that a break or continue statement can find its loop. The descriptor
  also saves data on blocks important to the loop.
}

    var
      l: loop_descriptor;


    begin
      new(l);
      with l^ do
        begin
        outer := this_loop;
        cont_block := cblock;
        break_block := bblock;
        cont_found := false;
        break_found := false;
        looploop := false;
        end;
      this_loop := l;
    end; {pushloop}


  procedure poploop;

{ Pop a previously pushed loop
}

    var
      l: loop_descriptor;


    begin
      l := this_loop;
      this_loop := l^.outer;
      dispose(l);
    end; {poploop}



  procedure updatecontext;

{ Called at the points in expression building where the results of
  updating a variable must be taken into account.  This is normally
  the point at which "newvarop"s are converted to "varops".  At
  this point, nodes which are marked "mustinvalidate" are invalidated,
  and the "mustinvalidate" flag is removed.  Such nodes are created
  when a "newvarop" is scanned.
}

    var
      i: 0..contextdepth; {induction var on context levels}


    procedure clobber(n: nodeindex {start of node chain} );

{ Scan the chain of nodes beginning with "n" and invalidate any with
  the "mustinvalidate" flag set.
}

      var
        p: nodeptr; {used for access to nodes}


      begin
        while n <> 0 do
          begin
          if bigcompilerversion then p := @(bignodetable[n]);
          with p^ do
            begin
            if valid and mustinvalidate then
              begin
              if not bigcompilerversion then blocksin[1].written := true;
              if deepestvalid > contextsp then deepestvalid := contextsp;
              valid := false;
              mustinvalidate := false;
              end;
            n := slink;
            end;
          end;
      end {clobber} ;


    begin
      if not (deadcode and (removedeadcode in genset)) then
        for i := context[contextsp].searchlevel to contextsp do
          clobber(context[i].opmap[0]);
    end {updatecontext} ;


  procedure updatenewvars(root: nodeindex {expression to process} );

{ Scan an expression rooted in "root" and convert all "newvarop" and
  "newunsvarop" notes to "varop" and "unsvarop" nodes, then enter
  them in the local opmap.

  "Newvarop" is generated when the value of the variable is to be updated
  in the current expression.  This update doesn't take place until the
  end of the expression evaluation, so the old value of the variable is
  available for use in common subexpressions within that expression.
  the "newvarop" is not entered in the opmap, and so is not available
  for common expression matching.  At the time when the update takes place,
  the expression is scanned and all "newvarop" nodes are changed to
  "varop" nodes and entered in the opmap for use in common expression
  matching.

  The global "newvarcount" is used to reduce the amount of time spent
  scanning the expression, as the scan can now be stopped as soon as the
  value of "newvarcount" goes to zero.  This is global as it applies to
  all levels of the recursive scan.
}

    var
      cnt: oprndindex; {induction var for scanning operands}
      p: nodeptr; {used for access to root node}
      newop: operatortype; {new operator if node is changed}


    procedure killvars(low, high: levelindex);

  { We have been writing through a pointer, and some offsets are used as
    special flags to describe what levels are killed.  This routine
    actually does the killing.
  }

      var
        n: nodeindex; {for tracing list of nodes}
        p: nodeptr; {for access to nodes}
        i: contextindex; {induction var}


      begin
        if (language = c) and not (deadcode and (removedeadcode in genset)) then
          begin
          if loopdepth > 0 then loopkill(low, high);
          for i := context[contextsp].searchlevel to contextsp do
            begin
            n := context[i].opmap[0];
            while n <> 0 do
              begin
              if bigcompilerversion then p := @(bignodetable[n]);
              with p^ do
                begin
                if not regcandidate and (oprnds[1] >= low) and
                   (oprnds[1] <= high) then
                  begin
                  valid := false;
                  if deepestvalid > contextsp then deepestvalid := contextsp;
                  end;
                n := slink;
                end;
              end;
            end; {for}
          updatecontext;
          end;
      end; {killvars}


    begin
      while (newvarcount > 0) and (root <> 0) do
        begin
        if bigcompilerversion then p := @(bignodetable[root]);
        if p^.action = visit then
          begin
          if (p^.op = newvarop) or (p^.op = newunsvarop) then
            begin
            if not bigcompilerversion then blocksin[1].written := true;
            newvarcount := newvarcount - 1;
            if p^.op = newvarop then newop := varop
            else newop := unsvarop;
            p^.op := newop;
            if language = c then
              begin
              if p^.oprnds[2] = ptr_any_off then killvars(1, level)
              else if p^.oprnds[2] = ptr_ext_off then killvars(1, 1)
              else if p^.oprnds[2] = ptr_loc_off then killvars(level, level);
              end;
            addopmap(root, newop, 0, contextsp);
            end
          else
            begin
            for cnt := 1 to 3 do
              if p^.nodeoprnd[cnt] and (newvarcount > 0) then
                begin
                updatenewvars(p^.oprnds[cnt]);
                if bigcompilerversion then p := @(bignodetable[root]);
                end;
            if p^.op < intop then root := p^.slink
            else root := 0;
            end
          end
        else root := 0;
        end;
    end {updatenewvars} ;



  procedure buildstmtlist(lasts: stmttype {statement to terminate build} ;
                          successorblock: basicblockptr { block succeeding this
                                                         list of stmts }
                          );

{ Build a sequential list of statements beginning at
  "currentblock^.beginstmt" and terminating when "lasts" is read from
  the input file.

  Statements which are executed sequentially (separated by ";" in the
  input) are simply linked  with the "nextstmt" field.  Since all
  structured statements are fully bracketed in the intermediate file,
  it is sufficient simply to build statements until the ending bracket
  specified by "lasts" is read.
}


    procedure buildstmt;

{ Build a single statement and link it on the list defined by
  currentblock^.beginstmt and currentlaststmt.
  "beginstmt" is intialized to zero prior to the first
  call to this procedure, and will be left pointing to the first
  statement built.  "currentlaststmt" will always point to the last
  statement added to the list, to simplify adding statements to the end.

  The first statement in the intfile is examined, the proper internal
  procedure called to build that statement type, and the result is
  linked on the list.  This set of procedures is, of course, highly
  recursive.
}

      var
        thisstmt: nodeindex; {statement being built}
        ptr: nodeptr; { for access to statement node }


      procedure assignvalue(movenode: nodeindex);
{
    Purpose:
      Assign a literal value to var or unsvar node for use in constant
      propagation.

    Inputs:
      movenode : A movelit/move-intop node.

    Outputs:
      none

    Algorithm:
      Examine left hand side ( oprnd[1] ) of movenode to see if it
      is a simple variable ( i.e. not an array or pointer reference ).
      If movelit op so set value field to the value in oprnds[2].

    Sideeffects:
      Var node may change.

    Last Modified: 8/9/85

}

        var
          thevar: nodeindex; { index of the var to assign value }
          thevalue: integer; { value to be assigned }
          ptr: nodeptr; { for access to nodes }


        begin {assignvalue}

          { top of stack is a movelit examine left hand side }

          if bigcompilerversion then ptr := @(bignodetable[movenode]);
          if ptr^.op = movelit then thevalue := ptr^.oprnds[2]
          else
            begin
            if bigcompilerversion then ptr := @(bignodetable[ptr^.oprnds[1]]);
            thevalue := ptr^.oprnds[1];
            end;
          thevar := ptr^.oprnds[1];
          { access the (new)varop }
          if bigcompilerversion then ptr := @(bignodetable[thevar]);
          { see if it is simple }
          if bigcompilerversion then ptr := @(bignodetable[ptr^.oprnds[3]]);
          if ptr^.op = indxop then
            begin
            if bigcompilerversion then ptr := @(bignodetable[ptr^.oprnds[1]]);
            if ptr^.op = levop then
              begin
              if bigcompilerversion then ptr := @(bignodetable[thevar]);
              ptr^.hasvalue := true;
              ptr^.value := thevalue;
              end;
            end;

        end {assignvalue} ;


      procedure buildproperptr(var oprnd: stackrecord; {opnd referenced}
                               contextlevel: contextindex {ref level} );

{ Build a valid local reference to an operand.  Since the operand is
  possibly defined at some outer context, and must have a copy node
  built in the local context, this routine scans all context levels
  from the operand definition level to the level at which it is used
  and inserts copy nodes if there are none already.  An appropriate
  copy node is then substituted for "oprnd".  The refcount and copycount
  of the base operand are incremented for each copy created.
  References within the local context do not need copies made, as changes
  in this node are easily taken into account by the code generator.

  Copy nodes for a context level are kept in a list based in the
  field "preconditions" for the first statement in the context.
  This list contains only copy nodes, and is generated prior to any
  other code for the statement.
}

        var
          j: contextindex; {induction var for context search}
          originallink: nodeindex; {points to formal parent of node}
          n1, n2: nodeindex; {pointers for tracing node list}
          ptr, ptr2: nodeptr; {used for node access}
          foundcopy: boolean; {true if copy found at this level}


        begin
          with oprnd do
            if not litflag and not (deadcode and
               (removedeadcode in genset)) then
              begin
              if (l <> 1) then
                begin
                originallink := p;
                for j := l + 1 to contextlevel do
                  with context[j] do
                    begin
                    n1 := firstblock^.precode;
                    foundcopy := false;
                    while (n1 <> 0) and not foundcopy do
                      begin
                      n2 := n1;
                      if bigcompilerversion then ptr := @(bignodetable[n1]);
                      foundcopy := (ptr^.oldlink = p);
                      n1 := ptr^.prelink;
                      end;
                    if not foundcopy then
                      begin
                      newexprnode(n2);
                      if bigcompilerversion then ptr := @(bignodetable[n2]);
                      ptr^.refcount := 0;
                      ptr^.copycount := 0;
                      ptr^.action := copy;
                      ptr^.prelink := firstblock^.precode;
                      ptr^.hoistedby := firstblock;
                      ptr^.oldlink := p;
                      ptr^.directlink := originallink;
                      firstblock^.precode := n2;
                      end;
                    if bigcompilerversion then ptr := @(bignodetable[p]);
                    with ptr^ do
                      begin
                      refcount := refcount + 1;
                      if ptr^.action = visit then
                        if ptr^.op = commaop then
                          increfcount(ptr^.oprnds[2], deadcode, 1);
                      copycount := copycount + 1
                      end;
                    p := n2;
                    end;
                end;
              end;
        end {buildproperptr} ;


      function insertexpression(var n: workingnode;
                                contextlevel: contextindex;
                                isunique: boolean;
                                relationbuilt: boolean; { true if oprnds are
                                                         relations }
                                var lev: contextindex; { it's context level}
                                var uniquenode: boolean {inserted node is
                                                         unique}
                                ): nodeindex;

{ Insert a expression node in the specified context, if necessary, and push a
  stack element with a reference to that node.

  If there is any possibility that the node may be found in the
  context stack then all levels are searched from the specified out
  to the outermost still valid (searchlevel).  If the operand exists
  already, a reference to it is pushed onto the stack, otherwise
  a new node is created from the working node and entered into the
  specified level.  "IsUnique" is used to speed up the search, and if
  the node is a new one, "uniquenode" is set true to speed up search
  for operators using the node.
}

        var
          level: shortint; {induction var for level search}
          insertindex: nodeindex; {prev node if found, else 0}


        procedure compare(nindex: nodeindex; {candidate match}
                          var equal: boolean {set if matched} );

{ Compare the node being constructed with a candidate node to see if they
  belong to the same equivalence class.  An equivalence class is
  defined by having the operators equal and all operands equivalent,
  where copies are considered equivalent to the node which they copy.

  The first node created is the representative of the entire equivalence
  class, and all equivalent nodes are represented as copies of that node
  or as references to that node.  For a node to be a candidate for
  consideration by this routine, it must be valid.

  Note: all operands are compared using the "i" field, even though
  some of them are actually nodes.  This relies on storage layout of the
  records, so is machine dependent.
}

          var
            p: nodeptr; {used for access to candidate}


          function getclass(i: oprndindex {operand number} ): integer;

{ Get the representative node of the equivalence class of operand
  "i" of the candidate node.  This routine simply gets the
  operand value if it is not a node (nodeoprnd off), or gets the node
  and strips off the copies to get the representative for the class.
}

            var
              ptr: nodeptr; {used to access node}


            begin
              with p^ do
                begin
                getclass := oprnds[i];
                if nodeoprnd[i] then
                  begin
                  if bigcompilerversion then
                    ptr := @(bignodetable[oprnds[i]]);
                  if ptr^.action = copy then getclass := ptr^.directlink;
                  end;
                end;
            end {Getclass} ;


          begin {Compare}
            if bigcompilerversion then p := @(bignodetable[nindex]);
            equal := p^.valid and (n.op = p^.op) and (n.form = p^.form) and
                     (n.len = p^.len);
            if equal then
              case language of
                pascal, modula2:
                  equal := (n.oprndlist[2].i = getclass(2)) and
                           (n.oprndlist[1].i = getclass(1)) and
                           (n.oprndlist[3].i = getclass(3));
                c:
                  if n.op = realop then
                    equal := fpcomp(n.rval, p^.realvalue) = 0
                  else
                    equal := (n.oprndlist[2].i = getclass(2)) and
                             (n.oprndlist[1].i = getclass(1)) and
                             (n.oprndlist[3].i = getclass(3));
                end;
          end {Compare} ;


        function addnode: nodeindex;

{ Create a new node and added it to the opmap at the specified level.
  This is called when there is no earlier expression to use.  First
  all operands are made available at the current level with "buildproperptr".
  The reference count for each operand is incremented, and then
  an new node is created an initialized with data from the workingnode
  "n" (global in buildnode).
}

          var
            hashvalue: maphashindex; {node hash value}
            i1: oprndindex; {induction var for operand handling}
            ptr: nodeptr; {provides access to new node}
            newptr: nodeindex; {resulting node}


          begin {addnode}
            hashvalue := hash(n.op, n.oprndlist[1].i, n.oprndlist[2].i);
            if (language <> c) or (n.op <> realop) then
              for i1 := 1 to 3 do
                with n, oprndlist[i1] do
                  begin
                  buildproperptr(oprndlist[i1], contextlevel);
                  if not litflag then increfcount(p, deadcode, 1);
                  end;
            newexprnode(newptr);
            addopmap(newptr, n.op, hashvalue, contextlevel);
            if bigcompilerversion then ptr := @(bignodetable[newptr]);
            with ptr^ do
              begin
              refcount := 0;
              copycount := 0;
              action := visit;
              op := n.op;
              form := n.form;
              len := n.len;
              ownvar := n.ownvar;
              regcandidate := false; {dodefine will set if node is}
              if (deadcode and (removedeadcode in genset)) then
                valid := false {any language}
              else if language = c then
                valid := (contextlevel = 1) or (cond_depth = 0) or
                           (call_depth = 0)
              else valid := true;
              cost := n.cost;
              relation := relationbuilt;
              local := cond_depth > 0;
              invariant := false;

              if (language = c) and (op = realop) then realvalue := n.rval
              else
                for i1 := 1 to 3 do
                  with n.oprndlist[i1] do
                    if not litflag then
                      begin
                      nodeoprnd[i1] := true;
                      oprnds[i1] := p;
                      end
                    else oprnds[i1] := i;
              end;
            addnode := newptr;
          end {addnode} ;


        procedure searchcontext(contextlevel: contextindex;
                                var nindex: nodeindex {result} );

{ Search a specified context level for a node equivalent to "n".
  "Nindex is set to the node if one exists, otherwise to zero.

  The chain from the hash value in opmap is simply searched sequentially.
}

          var
            n1: nodeindex; {Used to trace op map list}
            ptr: nodeptr; {Used for access to opmap nodes}
            found: boolean; {set if valid match is found}


          begin
            if (subexpressions in genset) or (contextlevel = 1) then
              begin
              n1 := context[contextlevel].opmap[hash(n.op, n.oprndlist[1].i,
                                                     n.oprndlist[2].i)];
              found := false;
              while not found and (n1 <> 0) do
                begin
                compare(n1, found);
                nindex := n1;
                if bigcompilerversion then ptr := @(bignodetable[n1]);
                n1 := ptr^.slink;
                end;
              if not found then nindex := 0;
              end
            else nindex := 0;
          end {searchcontext} ;


        begin {insertexpression}
                { if we are building useless stmts don't insert stuff
                  into lower levels!
                }
          if (deadcode and (removedeadcode in genset)) then
            contextlevel := contextsp;
          level := contextlevel + 1;
          insertindex := 0;
          if not isunique and (n.op >= intop) and (n.form <> bools) and
             ((n.op <> sysfn) or (n.oprndlist[1].i <> ord(timeid))) and
             ((call_depth = 0) or (cond_depth = 0) or (contextlevel = 1) or
             (language <> c)) then
            with context[contextlevel] do
              repeat
                level := level - 1;
                searchcontext(level, insertindex);
              until (level = searchlevel) or (insertindex <> 0);

          { if we didn't find it add it into the graph }

          if insertindex <> 0 then
            begin
            lev := level;
            insertexpression := insertindex;
            uniquenode := false;
            end
          else
            begin
            lev := contextlevel;
            insertexpression := addnode;
            uniquenode := true;
            end;
        end {insertexpression} ;


      function simplify(var root: integer): boolean;
{
    Purpose:
      Take the expression tree rooted in root and simplify it if possible.

    Inputs:
      root : root of expression tree.

    Outputs:
      root : root of modified expression tree.
      possibly modified/different expression tree.

    Algorithm:
      Search the tree for things we know how to simplify. This involves
      folding constant expressions. Also by using algebraic laws we
      can rearrange the expression so folding opportunities arise that
      otherwise wouldn't happen, e.g. "1+foo+5" ==> foo+1+5 ==> foo+6.
      Also some operators are converted to the "lit" flavor since some
      code generators appreciate it.

    Sideeffects:
      many if tree is modified.

    Last Modified: 8/8/85

}

        var
          nextroot: nodeindex; { for following slink chains }
          current: nodeindex; { sub graph we are working on now }
          ptr: nodeptr; { for accessing node }
          changes: boolean; { true if any important changes happen in a pass }
          intvalue: integer; { saved value of an integer operand }
          opnum: oprndindex; { operand we want to change }
          newop: operatortype; { new operator }
          newnode: workingnode; { basic intop node }
          result: boolean; { result of compare fold }
          op: operatortype; { save copy of node's op field }
          newoperands: operandarray; { copy of node's new oprnd field }
          oldoperands: operandarray; { saved copy of node's original oprnd field
                                      }
          nodeoperands: nodeoperandarray; { saved copy of node's nodeoprnd
                                           field}
          i: oprndindex; { induction var }


        procedure binaryfold(signedop: binaryfoldop;
		             unsignedop: binaryfoldop;
                             associate: operatortype);

{
    Purpose:
      Try and do folding of binary operator.

    Inputs:
      signedop : signed folding routine.
      unsignedop : unsigned folding routine.
      associate : the operator we can do associative rearrangement with.
                  ( e.g. 1+a+3, addop is associate and becomes a + 4 )

    Outputs:
      none

    Algorithm:
      Simple at the present. If expression has intops (unsintop?) as
      only operands call the appropriate folding routine. Since unsintop
      does not yet exist problem can exist if signop does not return
      the same value as unsignedop. We ignore that problem for now. This
      is reasonably safe, but should be fixed. Also algorithm should be
      expanded at some point to use associative law to fold things like
      1 + foo + 5 to foo + 6.

    Sideeffects:
      graph is modified

    Last Modified: 6/27/85

}

          var
            overflow: boolean; { true if arithmetic overflow occurs during fold
                                }
            leftp, rightp: nodeptr; { for access left and right nodes }
            lev: contextindex; { dummy var }


          begin {binaryfold}
            if bigcompilerversion then
              leftp := @(bignodetable[oldoperands[1]]);
            if bigcompilerversion then
              rightp := @(bignodetable[oldoperands[2]]);
            if (leftp^.op = intop) and (leftp^.action = visit) then
              begin
              if (rightp^.op = intop) and (rightp^.action = visit) then
                begin
                { fold it return new root }
                signedop(leftp^.oprnds[1], rightp^.oprnds[1],
                         newnode.oprndlist[1].i, overflow);
                if not overflow then
                  begin
                  simplify := true;
          { Replace root with this new folded node.  "current" == "root"
            whenever folding is possible, so this works better than it looks.
          }
                  root := insertexpression(newnode, 1, false, false, lev,
                                           result);
                  increfcount(root, deadcode, 1);
                  { 1 less use of the intop operands and this node }
            { don't bother this can drive refcount negative and intops
              are harmless anyway. When simplify is moved to improve phase
              this can come back.
            }
            {
            increfcount(oldoperands[1], deadcode, - 1);
            increfcount(oldoperands[2], deadcode,  - 1);
            }
                  end
                else
                  begin
                  { give an error message??? }
                  { for now ignore it }
                  end;
                end
              else if associate <> endexpr then
                begin
                { search rest of expression for another intop }
                end;
              end
            else if (rightp^.action = visit) and (rightp^.op = intop) and
                    (associate <> endexpr) then
              begin
              { search rest of expression for another intop }
              end;
          end {binaryfold} ;


        begin {simplify}
          simplify := false;
          changes := not (deadcode and (removedeadcode in genset));
          { init your basic intop }
          with newnode do
            begin
            len := targetintsize;
            cost := 0;
            form := none;
            op := intop;
            for i := 1 to 3 do
              with oprndlist[i] do
                begin
                relation := false;
                litflag := true;
                i := 0;
                end;
            end;
          while changes do
            begin
            changes := false;
            current := root;
            while current <> 0 do
              begin
              nextroot := 0;
              if bigcompilerversion then ptr := @(bignodetable[current]);
              if (ptr^.action = visit) then
                begin
                if (ptr^.op < intop) then nextroot := ptr^.slink;
          { can't simplify any cse's since we would have to find the
            other reference(s) to this node.
          }
                if (ptr^.form in
                   [none, ints, chars, subranges, bools, scalars]) and
                   (ptr^.refcount <= 1) then
                  begin
                  op := ptr^.op;
                  oldoperands := ptr^.oprnds;
                  newoperands := oldoperands;
                  nodeoperands := ptr^.nodeoprnd;
                  for i := 1 to 3 do
                    begin
                    if nodeoperands[i] then
                      begin
                      if simplify(newoperands[i]) then
                        begin
                        if bigcompilerversion then
                          ptr := @(bignodetable[oldoperands[i]]);
                        if ptr^.action = visit then
                          if (ptr^.op < intop) and (ptr^.op > newunsvarop) then
                            while ptr^.slink <> 0 do
                              begin
                              oldoperands[i] := ptr^.slink;
                              if bigcompilerversion then
                                ptr := @(bignodetable[oldoperands[i]]);
                              end;
                        if bigcompilerversion then
                          ptr := @(bignodetable[oldoperands[i]]);
                        ptr^.refcount := ptr^.refcount - 1;
                        ptr^.valid := ptr^.refcount > 0;
                        changes := true;
                        end;
                      end;
                    end;
                  { make the changes in this node }
                  if changes then
                    begin
                    if bigcompilerversion then
                      ptr := @(bignodetable[current]);
                    ptr^.oprnds := newoperands;
                    end;
                  { now can we simplify this node }
                  case op of
                    defforindexop, defunsforindexop, moveop, pushvalue:
                      begin
              { if previous changes made oprnd[opnum] constant
                change to lit type.  However don't count as a change
                since it is harmless }
                      case ptr^.op of
                        defforindexop:
                          begin
                          opnum := 3;
                          newop := defforlitindexop;
                          end;
                        defunsforindexop:
                          begin
                          opnum := 3;
                          newop := defunsforlitindexop;
                          end;
                        moveop:
                          begin
                          opnum := 2;
                          newop := movelit;
                          end;
                        pushvalue:
                          begin
                          opnum := 1;
                          newop := pushlitvalue;
                          end;
                        otherwise
                        end;
                      if bigcompilerversion then
                        ptr := @(bignodetable[newoperands[opnum]]);
                      if (ptr^.op = intop) and (ptr^.action = visit) then
                        begin
                        { remove ref count from the intop }
                        if not bigcompilerversion then
                          blocksin[1].written := true;
                        intvalue := ptr^.oprnds[1];
                        ptr^.refcount := ptr^.refcount - 1;
                        if bigcompilerversion then
                          ptr := @(bignodetable[current]);
                        ptr^.op := newop;
                        ptr^.oprnds[opnum] := intvalue;
                        ptr^.nodeoprnd[opnum] := false;
                        if (newop = movelit) and (propagation in genset) then
                          assignvalue(current);
                        end;
                      end;
                    lssop, leqop, neqop, eqop, gtrop, geqop:
                      begin
                      { if foldable do it, or if convertable to lit type do it }
                      if bigcompilerversion then
                        ptr := @(bignodetable[newoperands[2]]);
                      if (ptr^.op = intop) and (ptr^.action = visit) then
                        begin
                        { at least convert to lit form }
                        intvalue := ptr^.oprnds[1];
                        if bigcompilerversion then
                          ptr := @(bignodetable[newoperands[1]]);
                        if (ptr^.op = intop) and (ptr^.action = visit) then
                          case op of
                            lsslit: result := intvalue < ptr^.oprnds[1];
                            leqlit: result := intvalue <= ptr^.oprnds[1];
                            gtrlit: result := intvalue > ptr^.oprnds[1];
                            geqlit: result := intvalue >= ptr^.oprnds[1];
                            eqlit: result := intvalue = ptr^.oprnds[1];
                            neqlit: result := intvalue <> ptr^.oprnds[1];
                            end
                        else
                          begin
                          if bigcompilerversion then
                            ptr := @(bignodetable[current]);
                          ptr^.nodeoprnd[2] := false;
                          ptr^.oprnds[2] := intvalue;
                          case op of
                            lssop: ptr^.op := lsslit;
                            leqop: ptr^.op := leqlit;
                            neqop: ptr^.op := neqlit;
                            eqop: ptr^.op := eqlit;
                            gtrop: ptr^.op := gtrlit;
                            geqop: ptr^.op := geqlit;
                            end;
                          end;
                        end
                      end;
                    lsslit, leqlit, eqlit, neqlit, gtrlit, geqlit:
                      begin
                      intvalue := ptr^.oprnds[2]; {???}
                      if bigcompilerversion then
                        ptr := @(bignodetable[newoperands[1]]);
                      if false and (ptr^.op = intop) and
                         (ptr^.action = visit) then
                        begin
                  { can't really do the folding here yet since operands
                    could be unsigned and that will surely give wrong
                    results.
                  }
                        changes := true;
                        case op of
                          lsslit: result := intvalue < ptr^.oprnds[1];
                          leqlit: result := intvalue <= ptr^.oprnds[1];
                          gtrlit: result := intvalue > ptr^.oprnds[1];
                          geqlit: result := intvalue >= ptr^.oprnds[1];
                          eqlit: result := intvalue = ptr^.oprnds[1];
                          neqlit: result := intvalue <> ptr^.oprnds[1];
                          end
                        end;
                      end;
                    andop, orop:
                      begin
                      end;
                    plusop: binaryfold(@add, @usadd, plusop);
                    minusop: binaryfold(@subtract, @ussubtract, endexpr);
                    mulop: binaryfold(@multiply, @usmultiply, mulop);
                    kwoop: binaryfold(@divide, @usdivide, endexpr);
                    modop, stdmodop:
                      binaryfold(@remainder, @usremainder, endexpr);
                    divop, stddivop, quoop, remop:
                      begin
                      end;
                    negop, notop:
                      begin
                      end;
                    incop, decop:
                      begin
                      end;
                    { shiftlop some day...: }
                    otherwise;
                    end; {case}
                  end; {if foldable }
                end;
              current := nextroot;
              end; {while root}
            end; {while changes}

        end {simplify} ;


      function buildexpr: nodeindex;

{ Build an expression tree.  Called from various statement building
  procedures to build an expression (or group of expressions).

  This procedure reads the intermediate file and builds expressions
  until it reads an "endexpr" operator.  This may be a complicated
  group of expressions, for instance a procedure call with all arguments,
  but it will always be a tree with a single root, which is placed
  in "root".

  The tree as built must have assignment targets noted in it, an
  improvement which allows better code generation.  C allows nested
  assignment statements, so we can't use a simple on-the-fly
  algorighm to pick these up.  Instead, a "moveop" scans the left
  side looking for targets, then the right side marking instances
  of the target variable.  This is all done by the "marktargets"
  routine.
}

        var
          stackp: nodeptr;


        procedure sequence_point;

{ Invalidate all newvarops anywhere on the stack
}

          var
            i: natural;


          begin
            for i := sp downto 1 do
              if not stack[sp].litflag then updatenewvars(stack[sp].p);
            updatecontext;
          end;


        procedure clear_expr(expr: nodeindex; {expression to clear}
                             mark: nodeindex {last valid node} );

{ Scan an expression and invalidate all nodes which are later than "mark".
  This is used for conditional expressions, which may generate values on
  one path which do not exist on the other.  We don't try to take into
  account expressions which might be invalidated on one path and not the
  other.  We don't have enough bookkeeping info in the nodes for that
  one.  In some better world conditional expressions would be handled like
  all other control flow, but we don't have that yet.
}

          var
            p: nodeptr; {for access to entry}
            n: node; {local copy of the node}
            i: 1..3; {for scanning operands}


          begin
            if expr > mark then
              begin
              if bigcompilerversion then p := @(bignodetable[expr]);
              p^.valid := false;
              if p^.action in [visit, revisit] then
                begin
                n := p^;
                for i := 1 to 3 do
                  if n.nodeoprnd[i] then clear_expr(n.oprnds[i], mark);
                if (n.slink <> 0) and (n.op < intop) then
                  clear_expr(n.slink, mark);
                end;
              end;
          end; {clear_expr}


        procedure marktargets(left, right: nodeindex);

{ Scan the left side looking for a newvarnode, then scan the right side
  looking for varnodes with matching displacement.  The target flag is
  set in any matching nodes.
}

          var
            targfound: boolean; {we have found a target}
            targlev: integer; {target level}
            targoff: integer; {target offset}


          procedure define_target(n: nodeindex);

{ Scan a tree, searching for newvarops.  We check for the deepest
  nodes first in the fond hope that we will pick up the earliest
  newvarop.  Other ones might arise because we find volatile variables
  in C or "origin" variables in Pascal.
}

            var
              op: operatortype; {local copy of operator}
              oprnds: operandarray; {local copy of operands}
              nodeoprnd: nodeoperandarray; {says if oprnds are nodes}
              p: nodeptr; {for access to node}
              i: oprndindex; {induction var}


            begin {define_target}
              if n <> 0 then
                begin
                if bigcompilerversion then p := @(bignodetable[n]);

                if p^.action = copy then
                  begin
                  n := p^.directlink;
                  if bigcompilerversion then p := @(bignodetable[n]);
                  end;

                op := p^.op;
                oprnds := p^.oprnds;
                nodeoprnd := p^.nodeoprnd;
                for i := 1 to 3 do
                  if nodeoprnd[i] then define_target(oprnds[i]);
                if targfound and
                   (op in [newvarop, newunsvarop, varop, unsvarop]) then
                  begin
                  if (targlev = oprnds[1]) and (targoff = oprnds[2]) then
                    begin
                    p^.target := true;
                    p^.mustinvalidate := true;
                    end;
                  end
                else if (op = newvarop) or (op = newunsvarop) then
                  begin
                  targfound := true;
                  targlev := oprnds[1];
                  targoff := oprnds[2];
                  end;
                end;
            end; {define_target}


          begin {marktargets}
            targfound := false;
            define_target(left);
            if targfound then define_target(right);
          end; {marktargets}


        procedure buildnode;

{ Build the kind of node specified by the current operator in the intermediate
  file.  The node built will be left in stack[sp], and may consume operands
  which are already on the stack.

  The body of the procedure consists of a large case statement which
  selects the proper action for the particular node being built.

  The basic action for most nodes is to gather data in a working
  node, search the available context for a congruent node, and return
  a new node, a copy of an old node at an outer context, or a reference
  to an old node at the current context level.  For some nodes, of course,
  there are special actions needed.  If the node is new, and eligible
  for common expression use, it is inserted in the opmap of the current
  context.

  The "unique" flag is used to signal that the node contains at
  least one unique operand, so there is no need to search for it.
  This eliminates a lot of unnecessary searching.

  Some special nodes, such as constants, are inserted in context[1].
  Nodes in this context level are emitted at the beginning of the block,
  and no copies of them are ever made, since the code generator will
  never modify them.
}

          var
            relationbuilt: boolean; {There is a relation in this node}
            unique: boolean; {set if no possibility of prior congru. expr}
            ptr: nodeptr; {used for access to an operand node}
            tmp: stackrecord; {used to hold stack top for swap and temp}
            n: workingnode; {used to accumulate operands for node}
            i: oprndindex; {induction var for operand search}
            cnvts: standardids; {converted standard id}


          procedure insertnode(contextlevel: contextindex);

{ Insert a node in the specified context, if necessary, and push a
  stack element with a reference to that node.
}


            begin {Insertnode}
              if sp = maxexprstack then compilerabort(manytemps);
              sp := sp + 1;
              with stack[sp] do
                begin
                context_mark := 0;
                litflag := false;
                i := 0; {clear any previous junk}
                relation := relationbuilt;
                p := insertexpression(n, contextlevel, unique, relationbuilt, l,
                                      uniqueoprnd);
                end;
            end {insertnode} ;


          procedure insertnormal;

{ Insert a node in the current context, the normal action.
}


            begin
              insertnode(contextsp);
            end {insertnormal} ;


          procedure insertsequential;

{ Insert a node which can be linked by the sequential link (slink) to
  the previous node.  This is the case if oprnds[1] points to the previous
  node, and the result of evaluating the previous nodes is not used by
  this node.
}

            var
              newexprnode: nodeindex; {index for this node}
              newptr: nodeptr; {used to access top element on the stack}
              prevnode: nodeindex; {prior node}
              prevptr: nodeptr; {used to access previous operator}


            begin
              insertnormal;
              newexprnode := stack[sp].p;
              if bigcompilerversion then
                newptr := @(bignodetable[newexprnode]);
              if newptr^.oprnds[1] <> 0 then
                begin
                prevnode := newptr^.oprnds[1];
                if bigcompilerversion then
                  prevptr := @(bignodetable[prevnode]);
                if prevptr^.action = visit then
                  if (prevptr^.op > newunsvarop) and (prevptr^.op < intop) then
                    begin
                    stack[sp].p := newptr^.oprnds[1];
                    newptr^.oprnds[1] := 0;
                    newptr^.nodeoprnd[1] := false;
                    while prevptr^.slink <> 0 do
                      begin
                      prevnode := prevptr^.slink;
                      if bigcompilerversion then
                        prevptr := @(bignodetable[prevnode]);
                      end;
                    if bigcompilerversion then
                      prevptr := @(bignodetable[prevnode]);
                    prevptr^.slink := newexprnode;
                    end;
                end;
            end; {insertsequential}



          procedure buildintoprnds(count: oprndindex {number to build} );

{ Build "count" literal integer operands in the workingnode "n".
  These operands take their values from the next "count" records
  in the intfile.
}

            var
              t: oprndindex; {induction var}


            begin
              for t := 1 to count do
                with n.oprndlist[t] do
                  begin
                  read(tempfiletwo, tempfilebuf);
                  litflag := true;
                  relation := false;
                  i := getintfileint;
                  end;
            end {buildintopnrds} ;


          procedure collectopdata;

{ Collect the operand data (length, cost, form) provided with the
  normal binary or unary operands and save it in the workingnode "n".
}


            begin
              read(tempfiletwo, tempfilebuf);
              n.len := getintfileint;
              read(tempfiletwo, tempfilebuf);
              n.cost := min(getintfileint, maxcost);
              read(tempfiletwo, tempfilebuf);
              n.form := tempfilebuf.f;
            end {collectopdata} ;


          procedure collectoprnds(count: oprndindex {number of opnds} );

{ Collect "count" operands from the top of the stack and save them in
  the workingnode "n".  The global variables "unique" and "relationbuilt"
  are set if they are true for any operand.  If a relation is built, it
  is noted as part of the "cost" field in "n".  This is a hack to
  save data space during bootstrap.
}

            var
              i: oprndindex; {induction variable}


            begin
              for i := count downto 1 do
                begin
                unique := unique or stack[sp].uniqueoprnd;
                n.oprndlist[i] := stack[sp];
                sp := sp - 1
                end;
            end {collectoprnds} ;


          procedure collectwork(count: oprndindex {operand count} );

{ Do the work of collecting all necessary data for an operator.

  First the operator data is read, then "count" arguments obtained from
  the stack.  The results are left in "n".
}


            begin
              collectopdata;
              collectoprnds(count);
            end {collectwork} ;


          procedure collectargs(count: oprndindex {operand count} );

{ Collect data for a node with "count" operands, then create the
  node, insert it in the appropriate context, and push a reference
  to the node onto the stack.
}


            begin
              collectwork(count);
              insertnormal;
            end {collectargs} ;


          procedure collectseqargs(count: oprndindex {operand count} );

{ The same as collect args, except that "insertsequential" is used instead
  of "insertnormal
}


            begin
              collectwork(count);
              insertsequential;
            end; {collectseqargs}


          procedure killaffectedvars(s: stackindex {stack entry holding proc} );

{ Kill variables affected by current procedure call or procedure push.  For
  procedure params death to variables occurs somewhat before their allotted
  time has expired by Pascal semantics, but not by much.  Since proc params
  are quite rare we don't worry too much about "sub-optimality" in this case.
}

            var
              i: contextindex; {induction var on context levels}
              l, u: levelindex; {Level bounds within which to invalidate}
              cr: cseregionindex; {for clobbering cse's}


            procedure clobber(nindex: nodeindex {start of chain} );

{ Invalidate all variables on the chain headed by "nindex" which
  have lex levels between "l" and "u" inclusive, and, if global,
  fall within the deadly bounds of the proper cseregion.
}

              var
                ptr: nodeptr; {used for access to nodes}


              begin
                while nindex <> 0 do
                  begin
                  if bigcompilerversion then ptr := @(bignodetable[nindex]);
                  with ptr^ do
                    begin
                    if (oprnds[1] >= l) and (oprnds[1] <= u) and
                       ((oprnds[1] > 1) or (language = c) or
                       (oprnds[2] >= cseregiontable[cr, ownvar].low) and
                       (oprnds[2] <= cseregiontable[cr, ownvar].high)) then
                      begin
                      if not bigcompilerversion then
                        blocksin[1].written := blocksin[1].written or valid or
                                               (deepestvalid > contextsp);
                      valid := false;
                      if deepestvalid > contextsp then
                        begin
                        deepestvalid := contextsp;
                        end;
                      end;
                    nindex := slink;
                    end;
                  end;
              end {clobber} ;


            begin {killaffectedvars}
              if stack[s].litflag then
                begin
                if newtravrsinterface then
                  with new_proctable[stack[s].i div (pts + 1)]^[stack[s].i mod
                       (pts + 1)] do
                    begin
                    if stack[s].i <= cseregions then cr := stack[s].i
                    else cr := 0;
                    if globaldeath then l := 0
                    else l := 2;
                    if intlevelrefs then u := level - 1
                    else u := 1;
                    end
                else
                  with proctable[stack[s].i] do
                    begin
                    if stack[s].i <= cseregions then cr := stack[s].i
                    else cr := 0;
                    if globaldeath then l := 0
                    else l := 2;
                    if intlevelrefs then u := level - 1
                    else u := 1;
                    end
                end
              else
                begin
                cr := 0;
                l := 0;
                if language = modula2 then u := level
                else u := level - 1
                end;
              if not (deadcode and (removedeadcode in genset)) then
                begin
                if loopdepth > 0 then loopkill(l, u);
                for i := context[contextsp].searchlevel to contextsp do
                  clobber(context[i].opmap[0]);
                updatecontext;
                end;
            end {killaffectedvars} ;


          procedure callnode;

{ Build a node for a procedure call.  This has three operands, a
  literal with the proc index (for an explicit proc) or a node index
  (for a proc parameter), the "reserve" for the return value, and
  the parameter list.

  All newvarops in the parameter list must be converted to varops, and
  any variables which were modified must be invalidated.  Also, since
  no detailed data is kept on what variables are modified by the called
  procedure,  all variable which are defined at lex levels which the
  procedure might access must be invalidated.  In the case of a parameter
  procedure, we must assume that it can destroy everything in sight.
  If the procedure makes no references except to local and global
  variables, (intlevelrefs false) there is no need to invalidate
  intermediate level variables.

  The level and displacement are stored as operands in the varops for
  just this purpose.  Note that pointers and file buffer variables have
  a "level" of 0, and are invalidated whenever global vars are invalidated.
  The field "globaldeath" in the procedure table is used to indicate the
  need for global invalidation.
}

            var
              final: nodeindex; { index of final node on parm list }
              reserve: nodeindex; { index of reserve node on parm list }
              reverseparms: boolean; { true if we should reverse param list}


            function reverse(current, previous: nodeindex): nodeindex;
{
    Purpose:
      reverse the a link list of nodes linked through slink.

    Inputs:
      current : index of node we must switch slink field.
      previous : new value for slink field.

    Outputs:
      reverse : index of tail node in the list

    Algorithm:
      straight forward.

    Sideeffects:
      changes the nodes as described.

    Last Modified: 9/23/85

}

              var
                ptr: nodeptr; { for access to current node }


              begin {reverse}
                if bigcompilerversion then ptr := @(bignodetable[current]);
                if ptr^.slink = 0 then
                  begin
                  reverse := current;
                  if not bigcompilerversion then blocksin[1].written := true;
                  ptr^.slink := previous;
                  end
                else
                  begin
                  reverse := reverse(ptr^.slink, current);
                  ptr^.slink := previous;
                  end;
              end {reverse} ;


            begin
              call_depth := call_depth - 1;
              updatenewvars(stack[sp - 1].p);
              reverseparms := false;
              with stack[sp - 2] do
                if litflag and (language <> c) then
                { reverse parameters if calling c on some machines }
                  if newtravrsinterface then
                    begin
                    with new_proctable[i div (pts + 1)]^[i mod (pts + 1)] do
                      if (calllinkage = nonpascalcall) and (stack[sp].i > 1) and
                         ((targetmachine = iAPX86) or
                         (targetmachine = i80386) or
                         (targetmachine = mc68000) or (targetopsys = vms) or
                         (targetmachine = ns32k) and (unixtarget = umax)) then
                        begin
                        reverseparms := true;
                        { remember where reserveop is while it's cheap }
                        reserve := stack[sp - 1].p;
                        end
                    end
                  else
                    begin
                    with proctable[i] do
                      if (calllinkage = nonpascalcall) and (stack[sp].i > 1) and
                         ((targetmachine = iAPX86) or
                         (targetmachine = i80386) or
                         (targetmachine = mc68000) or (targetopsys = vms) or
                         (targetmachine = ns32k) and (unixtarget = umax)) then
                        begin
                        reverseparms := true;
                        { remember where reserveop is while it's cheap }
                        reserve := stack[sp - 1].p;
                        end;
                    end;
              killaffectedvars(sp - 2);
              collectargs(3);
                { now that all the refcounts are set reverse parameter list
                 if calling "c".
                }
              if reverseparms then
                begin
                { first on list is the reserve }
                if bigcompilerversion then
                  begin
                  ptr := @(bignodetable[reserve]);
                  ptr^.slink := reverse(ptr^.slink, 0);
                  end
                end;

            end {callnode} ;


          procedure pushprocnode;


            begin {pushprocnode}
              killaffectedvars(sp);
              collectseqargs(3);
            end {pushprocnode} ;


          procedure buildvarnode;

{ Build a node for a variable reference.  The length of the variable is
  read from the file, then level and displacement are read and made into
  operands 1 and 2.  These are used as an identification for the
  variable when specific variables need to be invalidated, or for checking
  for the target.

  If the variable is the same as the target, it is marked as a target node
  and the "mustinvalidate" bit is set to invalidate this node at the next
  update time.
  If the variable has a known value we substitute a reference to it's
  value which is much cheaper.
}

            var
              stackp: nodeptr; {used to access top of stack node}
              i: oprndindex; { induction var }


            begin {buildvar}
              read(tempfiletwo, tempfilebuf);
              n.len := getintfileint;
              buildintoprnds(2);
              n.oprndlist[3] := stack[sp];
              read(tempfiletwo, tempfilebuf);
              unique := (language = c) and (n.oprndlist[2].i >= ptr_loc_off);
              n.ownvar := boolean(getintfileint);
              sp := sp - 1;
              insertnormal;
              if bigcompilerversion then
                stackp := @(bignodetable[stack[sp].p]);
              { if the var has a value assigned use that instead }
              {travrs does not yet handle extended range variables...}
              if stackp^.hasvalue and ((n.op = varop) or
                 (stackp^.value > 0)) then
                begin
                { should tell some one that operand is now a literal
                  and can be folded. Future plans...
                }
                n.op := intop;
                n.len := targetintsize;
                n.oprndlist[1].i := stackp^.value;
                n.oprndlist[2].i := 0;
                n.oprndlist[3].i := 0;
                for i := 1 to 3 do
                  begin
                  n.oprndlist[i].litflag := true;
                  n.oprndlist[i].relation := false;
                  end;
                sp := sp - 1;
                insertnode(1);
                end
              else
                begin
                unique := n.oprndlist[3].uniqueoprnd or (language = c) and
                          (n.oprndlist[2].i >= ptr_loc_off);
                if not (deadcode and (removedeadcode in genset)) then
                  doreference(stack[sp].p);
                end;
            end {buildvarnode} ;


          procedure buildnewvarnode;

{ Build a node for a "newvarop" or "newunsvarop".  This is a flag
  to the tree builder that this is going to be an assignment target,
  and will be changed to a "varop" at the next update time.  In the mean
  time, references to the variable of the same name can be optimized.

  All variables which match in level and displacement will have their
  "mustinvalidate" flag set so they will become invalid at the
  next update.
}

            var
              j: contextindex; {induction var on levels}
              stackp: nodeptr; {used to access top of stack node}
              p: nodeptr; { for access to nodes }


            procedure clobber(n1: nodeindex {start of chain} );

{ Set the "mustinvalidate" flag for all variable nodes on the
  chain rooted in "n1" which have the same level and displacement as
  the variable being created.

  The global "newvarcount" is incremented to keep track of how many
  are created.  This allows termination of the scan on "updatecontext"
  as soon as all targets are accounted for.
}

              var
                ptr: nodeptr; {used for node access}


              begin
                while n1 <> 0 do
                  begin
                  if bigcompilerversion then ptr := @(bignodetable[n1]);
                  with ptr^ do
                    begin
                    if valid and (oprnds[1] = n.oprndlist[1].i) and
                       (oprnds[2] = n.oprndlist[2].i) then
                      begin
                      if not bigcompilerversion then
                        blocksin[1].written := true;
                      mustinvalidate := true;
                      end;
                    n1 := ptr^.slink;
                    end;
                  end;
              end {clobber} ;


            begin
              { if dead part of tree don't recognize this }
              if (deadcode and (removedeadcode in genset)) then
                begin
                n.op := varop;
                buildvarnode;
                end
              else
                begin
                read(tempfiletwo, tempfilebuf);
                n.len := getintfileint;
                buildintoprnds(2);
                n.oprndlist[3] := stack[sp];
                read(tempfiletwo, tempfilebuf);
                unique := (language = c) and (n.oprndlist[2].i >= ptr_loc_off);
                n.ownvar := boolean(getintfileint);
                sp := sp - 1;
                insertnormal;
                dodefine(stack[sp].p);
                for j := contextsp downto context[contextsp].searchlevel do
                  clobber(context[j].opmap[0]);
                newvarcount := newvarcount + 1;
                end;
            end {buildnewvarnode} ;


          procedure builddeffor;

{ Build a defforindex operator.  Only tricky thing is that we must
  remove the effect of the "dodefine" spawned by the control var's
  definition.  It will be re-inserted inside the for loop by the
  routine "buildfor"
}

            var
              p: nodeptr;


            begin {builddeffor}
              { must defer the define until after from and to done }
              read(tempfiletwo, tempfilebuf);
              n.len := getintfileint;
              buildintoprnds(1);
              n.oprndlist[3] := stack[sp];
              sp := sp - 1;
              n.oprndlist[2] := stack[sp];
              sp := sp - 1;
              insertnormal;
              if bigcompilerversion then
                p := @(bignodetable[n.oprndlist[2].p]);

              { If we're within a loop, unhook for-loop control variable
                from the list of writes, as it really belongs within the
                loop (gets "more valuable" and more likely to be assigned
                a register).  If we don't unhook, exitloop will hook 'em
                in a circle as it appends the inner-loop writes to the outer
                loop's.  It doesn't check for duplicates, as this is impossible
                except for for-loops control vars, which are explicit CSE's
                throughout the life of the loop.  Of course, if this is a
                dead level, it hasn't been put on the write list at all,
                in which case we probably ought not remove it!
              }

              if (loopdepth > 0) and
                 not loopstack[loopdepth].deadlevels[level] then
                begin
                if bigcompilerversion then
                  p := @(bignodetable[n.oprndlist[2].p]);
                loopstack[loopdepth].writes := p^.looplink;
                if loopstack[loopdepth].writes = 0 then
                  loopstack[loopdepth].lastwrite := 0;
                p^.looplink := 0;
                end;

              with forstack[forsp], stack[sp] do
                begin
                forref := p;
                forlevel := l;
                end;
            end {builddeffor} ;


          procedure pushlitint;

{ Push a literal integer onto the stack.
}


            begin
              if sp = maxexprstack then compilerabort(manytemps);
              sp := sp + 1;
              with stack[sp] do
                begin
                context_mark := 0;
                relation := false;
                litflag := true;
                uniqueoprnd := false;
                read(tempfiletwo, tempfilebuf);
                i := getintfileint;
                end;
            end;


          procedure buildptrnode;

{ Build a node for a NIL pointer.  This is inserted into the tree
  as an integer value.
}


            begin {buildptrnode}
              n.len := ptrsize;
              pushlitint;
              if language = c then
                begin
                pushlitint;
                collectoprnds(2);
                end
              else collectoprnds(1);
              insertnode(1);
            end {buildptrnode} ;


          procedure buildrealnode(rsize: shortint; {size of a real}
                                  form: types {reals or doubles} );

{ Build a node for a real number.

  Currently, only "C" represents all real constants in IEEE extended
  form, as other language definitions make no provision for compile
  time (i.e. folding) arithmetic to yield different answers than
  calculations performed at runtime.

  Build a node for a real number.  This is inserted into the
  tree as a set of nodes, with the least significant part
  being inserted first. This allows the sharing of these
  nodes.  They will be written as a unit when the tree is
  walked. The chain of values is linked through oprnds[3],
  and the chain is terminated when oprnds[3] = 0.
}

            var
              intpieces, {number of integers per real}
               j: 0..maxrealwords; {induction var}


            begin
              case language of
                c:
                  begin
                  read(tempfiletwo, tempfilebuf);
                  n.len := getintfileint;
                  getintreal(n.rval);
                  insertnode(1);
                  end;
                pascal, modula2:
                  begin
                  n.len := rsize;
                  n.form := form;
                  case targetmachine of
                    iapx86: intpieces := 2; {MUST BE IMPROVED}
                    otherwise
                      intpieces := maxrealwords div (hostfileunits *
                                   hostintsize);
                    end;

                  for j := 1 to intpieces do pushlitint;

                  if odd(intpieces) then j := 1
                  else j := 2;

                  collectoprnds(j);
                  insertnode(1);
                  intpieces := intpieces - j;

                  while intpieces > 0 do
                    begin
                    collectoprnds(3);
                    insertnode(1);
                    intpieces := intpieces - 2;
                    end;
                  end;
                end;
            end {buildreal} ;


          begin {buildnode}
            { Initialize the working node }

            relationbuilt := false;
            unique := false;
              { if the statement we are collecting now are useless don't
                search for them!
              }
            unique := deadcode and (removedeadcode in genset);
            n.len := targetintsize;
            n.cost := 0;
            n.ownvar := false;
            n.op := tempfilebuf.o;
            n.form := none;
            for i := 1 to 3 do
              with n.oprndlist[i] do
                begin
                relation := false;
                litflag := true;
                l := 0;
                i := 0
                end;

            case n.op of
              jumpvfuncop:
                begin
                buildintoprnds(2);
                insertnormal;
                end;

              deleteop:
                begin
                collectwork(1);
                increfcount(n.oprndlist[1].p, deadcode, - 1);
                end;

              addrop:
                begin
                { must remove as register candidate}
                { top of stack is var we want address of }
                if not (deadcode and (removedeadcode in genset)) then
                  begin
                  killasreg(stack[sp].p);
                  end;
                collectargs(1);
                end;
              float, negop, indrop, filebufindrop, incop, decop, remop, quoop,
              ptrchkop, pushcvalue, definelazyop, setbinfileop, copystackop,
              closerangeop, chrstrop, arraystrop, groupop, compop, float_double,
              real_to_dbl, dbl_to_real:
                collectargs(1);
              tempop:
                begin
                collectwork(1);
                unique := true;
                insertnormal;
                end;
              dummyargop: collectseqargs(2);
              setfileop:
                begin
                killinput := false;
                collectargs(1);
                end;
              pushfinal:
                begin
                collectargs(1);
                if bigcompilerversion then
                  ptr := @(bignodetable[n.oprndlist[1].p]);
                if (ptr^.action = visit) and (ptr^.op = intop) then
                  begin
                  { just return the integer }
                  stack[sp].p := n.oprndlist[1].p;
                  end;
                end;
              wr: collectseqargs(1);
              rd:
                begin
                collectopdata;
                if n.form in [arrays, strings, files] then collectoprnds(1)
                else collectoprnds(2);
                insertsequential;
                end;
              setelt, plusop, minusop, mulop, bldset, divop, stddivop,
              dummyarg2op, slashop, kwoop, modop, stdmodop, shiftlop, indxop,
              pindxop, aindxop, paindxop, forerrchkop, loopholeop, shiftrop,
              xorop, returnop, castfptrop, castintop, castptrop, castrealop:
                collectargs(2);
              openarrayop:
                begin
                collectwork(2);
                insertnode(1);
                sp := 0; {throw it away}
                end;
              commaop:
                begin
                collectargs(2);
                increfcount(n.oprndlist[1].p, deadcode, - 1);
                increfcount(n.oprndlist[2].p, deadcode, - 1);
                end;
              clearnewop: sequence_point;
              saveop:
                begin
                sequence_point;
                stack[sp].context_mark := lastnode;
                cond_depth := cond_depth + 1;
                end;
              restop:
                begin
                sequence_point;
                clear_expr(stack[sp].p, stack[sp - 1].context_mark);
                stack[sp].context_mark := lastnode;
                end;
              questop:
                begin
                sequence_point;
                clear_expr(stack[sp].p, stack[sp - 1].context_mark);
                cond_depth := cond_depth - 1;
                collectargs(3);
                end;
              vindxop: collectargs(3);
              parmop: collectargs(2);
              moveop:
                begin
                collectwork(2);
                marktargets(n.oprndlist[1].p, n.oprndlist[2].p);
                insertnormal;
                if language = c then sequence_point;
                end;
              movelit:
                begin
                collectwork(2);
                marktargets(n.oprndlist[1].p, 0);
                insertnormal;
                if (n.form = ints) and (propagation in genset) then
                  assignvalue(stack[sp].p);
                end;
              addeqop, andeqop, diveqop, modeqop, muleqop, oreqop, shiftleqop,
              shiftreqop, subeqop, xoreqop, preincop, postincop:
                begin {Could fold these, but we won't bother yet}
                increfcount(stack[sp - 2].p, deadcode, 1);
                collectargs(3);
                end;
              pushaddr, pushstraddr:
                begin
                { must remove as register candidate}
                { top of stack is the address to push }
                if not (deadcode and (removedeadcode in genset)) then
                  begin
                  killasreg(stack[sp].p);
                  end;
                collectseqargs(2);
                end;
              pushvalue, pushlitvalue, bldfmt, pushfptr: collectseqargs(2);
              pushret: collectseqargs(2);
              notop:
                begin
                collectopdata;
                if language = c then relationbuilt := n.form = bools
                else
                  relationbuilt := (n.form = bools) and (shorteval or
                                   stack[sp].relation);
                collectoprnds(1);
                insertnormal;
                end;
              andop, orop:
                begin
                collectopdata;
                if (language = c) or (language = modula2) then
                  begin
                  relationbuilt := n.form = bools;
                  if relationbuilt then
                    begin
                    sequence_point;
                    clear_expr(stack[sp].p, stack[sp - 1].context_mark);
                    cond_depth := cond_depth - 1;
                    end;
                  end
                else
                  relationbuilt := (n.form = bools) and (shorteval or
                                   stack[sp].relation or
                                   stack[sp - 1].relation);
                collectoprnds(2);
                insertnormal;
                end;
              setpair, forupchkop, fordnchkop, cmoveop: collectargs(3);
              pushproc: pushprocnode;
              rangechkop, indxchkop, cindxchkop, congruchkop:
                begin
                collectopdata;
                if not stack[sp - 2].relation or
                   (stack[sp - 1].i <> ord(false)) or
                   (stack[sp].i <> ord(true)) then
                  begin
                  collectoprnds(3);
                  insertnormal;
                  end
                else sp := sp - 2;
                end;
              call, callparam, unscall, unscallparam: callnode;
              sysfn:
                begin
                collectopdata;
                cnvts := standardids(stack[sp - 1].i);
                if (n.form = bools) and not (cnvts in [predid, succid]) then
                  relationbuilt := true;
                unique := cnvts in
                          [frexpid, modfid, memcpyid, memmoveid, memsetid,
                          strcatid, strcpyid, strncpyid, strncatid];
                collectoprnds(2);
                insertnormal;
                end;
              lsslit, leqlit, eqlit, neqlit, gtrlit, geqlit, lssop, leqop,
              neqop, eqop, gtrop, geqop, inop:
                begin
                relationbuilt := true;
                collectargs(2)
                end;
              float1, chrstrop1, arraystrop1:
                begin
                tmp := stack[sp];
                sp := sp - 1;
                collectargs(1);
                sp := sp + 1;
                stack[sp] := tmp;
                end;
              defforindexop, defunsforindexop, defforlitindexop,
              defunsforlitindexop:
                builddeffor;
              forindexop:
                begin {Use for stack to locate var}
                read(tempfiletwo, tempfilebuf);
                begin
                with forstack[getintfileint] do
                  begin
                  if sp = maxexprstack then compilerabort(manytemps);
                  sp := sp + 1;
                  with stack[sp] do
                    begin
                    context_mark := 0;
                    relation := false;
                    litflag := false;
                    uniqueoprnd := false;
                    p := forref;
                    l := forlevel;
                    end;
                  if not (deadcode and (removedeadcode in genset)) then
                    if bumpvarcount(level, false, forref) then {nothing} ;
                  end;
                end;
                end;
              levop:
                case targetmachine of
                  vax, i80386, mc68000:
                    begin
                    buildintoprnds(2);
                    if (n.oprndlist[1].i <> 0) and
                       (n.oprndlist[1].i <> level) then
                      begin
                      n.oprndlist[3] := stack[sp];
                      sp := sp - 1;
                      end;
                    if (n.oprndlist[1].i = level) then
                      begin
                      insertnode(1);
                      localparamnode := stack[sp].p;
                      end
                    else insertnormal;
                    end;
                  otherwise
                    begin
                    buildintoprnds(1);
                    if n.oprndlist[1].i <> 0 then
                      begin
                      n.oprndlist[2] := stack[sp];
                      sp := sp - 1;
                      end;
                    insertnormal;
                    end;
                  end;
              reserve:
                begin
                call_depth := call_depth + 1;
                if language = c then
                  begin
                  buildintoprnds(2);
                  n.oprndlist[3] := n.oprndlist[2];
                  end
                else buildintoprnds(1);
                if stack[sp].litflag then
                  begin
                  n.oprndlist[2].i := stack[sp].i;
                  if (language <> c) and (n.oprndlist[2].i = 0) then
                    sp := sp - 1;
                  end
                else n.oprndlist[2].i := 0;
                insertnormal;
                end;
              intop:
                begin {this and other literals are entered in context 1}
                buildintoprnds(1);
                insertnode(1);
                end;
              fptrop:
                begin
                buildintoprnds(1);
                insertnode(1);
                end;
              ptrop: buildptrnode;
              realop: buildrealnode(targetrealsize, reals);
              doubleop: buildrealnode(doublesize, doubles);
              structop:
                begin
                buildintoprnds(2);
                n.len := n.oprndlist[2].i;
                insertnormal;
                end;
              varop, unsvarop: buildvarnode;
              newvarop, newunsvarop: buildnewvarnode;
              ownop: insertnode(1);
              extop:
                begin
                buildintoprnds(1);
                if targetmachine in [iAPX86, i80386] then
                  if switcheverplus[largemodel] then
                    begin
                    n.oprndlist[2] := stack[sp];
                    sp := sp - 1;
                    end;
                insertnormal;
                end;
              globalop:
                begin
                n.op := levop;
                with n.oprndlist[1] do
                  begin
                  relation := false;
                  litflag := true;
                  i := 1
                  end;
                insertnode(1);
                end;
              originop, segop:
                begin
                buildintoprnds(1);
                insertnormal;
                end;
              localop:
                begin
                n.op := levop;
                with n.oprndlist[1] do
                  begin
                  litflag := true;
                  relation := false;
                  i := level
                  end;
                insertnode(1);
                end;
              lit: pushlitint;
              withop:
                begin
                if sp = maxexprstack then compilerabort(manytemps);
                sp := sp + 1;
                read(tempfiletwo, tempfilebuf);
                with stack[sp] do
                  begin
                  context_mark := 0;
                  relation := false;
                  litflag := false;
                  uniqueoprnd := false;
                  with withstack[getintfileint] do
                    begin
                    l := withlevel;
                    p := withref;
                    end;
                  end;
                end;
              switchstack:
                begin
                tmp := stack[sp];
                stack[sp] := stack[sp - 1];
                stack[sp - 1] := tmp
                end;
              bldnil, newset:
                begin
                sp := sp + 1;
                with stack[sp] do
                  begin
                  context_mark := 0;
                  relation := false;
                  uniqueoprnd := false;
                  litflag := false;
                  l := 1;
                  p := 0
                  end;
                end;
              daddop, daddrop, dfaddrop, dfieldop, dfillop, dintop, drealop,
              dstartop, dstoreop, dstructop, dsubop, dendop:
                take_data_op;
              otherwise
                begin
                write('travrs build error', ord(n.op));
                compilerabort(builderror);
                end;
              end;
            read(tempfiletwo, tempfilebuf);
          end {buildnode} ;


        begin {buildexpr}
          newvarcount := 0;
          sp := 0;
          cond_depth := 0;
          call_depth := 0;
          while tempfilebuf.o <> endexpr do buildnode;
          if sp > 0 then
            begin
            updatenewvars(stack[sp].p);
            if spare6 in genset then { temp}
              if simplify(stack[sp].p) then;
            if sp > 1 then
              begin
              updatenewvars(stack[sp - 1].p);
              if spare6 in genset then { temp}
                if simplify(stack[sp - 1].p) then;
              end;
            updatecontext;
            buildproperptr(stack[sp], contextsp);
            buildexpr := stack[sp].p;
            increfcount(stack[sp].p, deadcode, 1);
            end
          else buildexpr := 0;
          read(tempfiletwo, tempfilebuf);
        end {buildexpr} ;



{ Statement Building Routines - -
  These are the routines which are used by buildstmt to build the
  individual statement nodes.
}


      procedure setupstmt(stmtkind: stmthdrtype {statement being built} );

{ This procedure handles the common part of those statement types which
  require an expression as part of the heading.  It creates a new
  statement of the specified type in the global "thisstmt" and
  builds an expression tree rooted in "expr1" of that statement node.
}

        var
          exprroot: nodeindex;
          ptr: nodeptr;


        begin
          newstmt(thisstmt, stmtkind);
          read(tempfiletwo, tempfilebuf);
          exprroot := buildexpr;
          if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
          ptr^.expr1 := exprroot;
        end {setupstmt} ;


      procedure buildifstmt;

{ Build an if statement, possibly followed by an else part.  The context
  is saved and restored on each branch so that both branches start out
  with the same common expressions.  Finally the contexts are joined
  to invalidate those expressions which were invalidated on either
  branch of the if.
}

        var
          startblock: basicblockptr; { currentblock at start }
          thenblock: basicblockptr; { id of then block }
          elseblock: basicblockptr; { id of else block }
          endthenblock: basicblockptr; {the end of the "then" portion}
          ifstmthdr: nodeindex; { index to ifhdr stmt }
          ptr: nodeptr;
          removing: boolean; { true if we have constant if and eliminating dead
                              code }
          start_deadcount: natural; {starting value of deadcount}
          deadthen: boolean; { true if removing and then is dead }
          deadelse: boolean; { true if removing and else is dead }
          constvalue: integer; { value if constant }
          saveminfon, { fon before stmtlist }
           savemaxfon: fonrange; { fon after stmtlist }


        begin

          shorteval := true;
          setupstmt(ifhdr);
          ifstmthdr := thisstmt;
          start_deadcount := deadcount;
          if bigcompilerversion then ptr := @(bignodetable[ifstmthdr]);
          checkconst(ptr^.expr1, removing, constvalue);
          shorteval := false;
          startblock := currentblock;
          removing := removing and (removedeadcode in genset);
          elseblock := nil;
          deadthen := removing and (constvalue = 0);
          deadelse := removing and (constvalue = 1);
          { starting a new basic block }
          if deadthen then incr_deadcount;
          { always enter a new context unless removing and we take then path}
          { not deadelse == not removing or ( constvalue = 0 )) }
          newblock(thenblock, startblock, false);
          if not removing or (deadcode and (removedeadcode in genset)) then
            begin
            savecontext;
            thenblock^.saveop := true;
            end;
          saveminfon := foncount;
          buildstmtlist(endthen, nil);
          savemaxfon := foncount;
          foncount := saveminfon;
          if not removing or (deadcode and (removedeadcode in genset)) then
            restorecontext;
          if deadthen then decr_deadcount;
          dead_exit(start_deadcount);
          endthenblock := currentblock;
          if tempfilebuf.s = begelse then
            begin
            read(tempfiletwo, tempfilebuf);
            { starting a new basic block }
            if deadelse then incr_deadcount;
            newblock(elseblock, startblock, false);
            elseblock^.restoreop := thenblock^.saveop;
            if not removing or (deadcode and (removedeadcode in genset)) then
              begin
              savecontext;
              elseblock^.saveop := true;
              end;
            buildstmtlist(endelse, nil);
            if not removing or (deadcode and (removedeadcode in genset)) then
              restorecontext;
            if deadelse then decr_deadcount;
            dead_exit(start_deadcount);
            end;

          newblock(currentblock, currentblock, false);
          addpredsuccs(endthenblock, currentblock);
          if elseblock = nil then
            begin
            addpredsuccs(startblock, currentblock);
            elseblock := currentblock;
            currentblock^.restoreop := thenblock^.saveop;
            end
          else currentblock^.restoreop := elseblock^.saveop;
          if thenblock^.saveop or elseblock^.saveop then
            begin
            joincontext;
            currentblock^.joinop := true;
            end;

          if bigcompilerversion then ptr := @(bignodetable[ifstmthdr]);
          if deadthen or deadelse then ptr^.stmtkind := nohdr
          else
            begin
            ptr^.trueblock := thenblock;
            ptr^.falseblock := elseblock;
            end;

          foncount := max(savemaxfon, foncount) + 1;
          currentblock^.dominates := context[contextsp].dominates;

        end {buildifstmt} ;


{ Case statements -
  Yet another case where the general lack of structure in C makes it
  hard to generate good code.  The Pascal case statement is nicely
  structured, and requires that the cases be immediately contained
  within the statement.  It also transfers to the exit label after
  each case, making a nice generalization of a multi-way "if".
  The C switch statement, on the other hand, is much closer to a
  computed goto, where control can be transfered anywhere within the
  compound statement following the switch, including within nested
  statements.  Also, control transfers to the exit only when the
  user includes a "break", making a hash of attempts to keep track
  of CSE's.

  The following set of routines maintain a stack of case descriptors
  which contain the data about all currently active case statements.
  They are called in a disciplined, sensible way when processing
  Pascal, and in a messy way when processing C.

    start_case          Define the top of a case statement
    start_label_group   Start of a new block with labels
    insert_caselab      Insert a case label in a group
    insert_casedef      Insert a default label in a group
    end_label_group     End of a group of labels
    case_break          Insert a break statement
    finish_case         Terminate a case statement
}


      procedure start_case;

{ Allocate and initialize a new case descriptor, then get the
  case expression and set up a case statement.  This mainly initialized
  a lot of things.
}

        var
          this_descr: case_descriptor;


        begin
          new(this_descr);
          with this_descr^ do
            begin
            outer := this_case;
            entry_dead := deadcode and (removedeadcode in genset);
            start_deadcount := deadcount;
            firstorder := 0;
            lastorder := 0;
            lastlab := 0;
            firstsplit := 0;
            splitcount := 0;
            casetopblock := currentblock;
            newstmt(casetopstmt, casehdr);
            read(tempfiletwo, tempfilebuf);
            caseexpr := buildexpr;
            checkconst(caseexpr, removing, constvalue);
            removing := removing and (removedeadcode in genset);
            if bigcompilerversion then ptr := @(bignodetable[casetopstmt]);
            ptr^.selector := caseexpr;
            newblock(tailblock, nil, false);
            currentblock := casetopblock;
            {***This is a total hack to avoid having walk explicitly emit
                a "savelabel(0)", which disappears when code is dead, dead,
                dead.
            }
            newblock(currentblock, currentblock, false);
            currentblock^.saveop := not removing;
            tailblock^.joinop := not removing;
            tailblock^.restoreop := not removing;
            found := false;
            saveminfon := foncount;
            savemaxfon := foncount;
            if not removing then savecontext;
            contextlev := contextsp + overflowdepth;
            loopd := loopdepth;
            old_swbreak_found := swbreak_found;
            old_caselab_found := caselab_found;
            caselab_found := false;
            casedef_found := false;
            last_dead := false;
            found := false;
            ever_found := false;
            otherflow := false;
            swbreak_found := true;
            lab_found := false;
            if language = c then
              begin {have to have a block for code}
              newblock(currentblock, currentblock, false);
              currentblock^.isdead := removedeadcode in genset;
              addpredsuccs(currentblock, currentblock);
              end;
            incr_deadcount;
            gotodead := gotodead + 1;
            end;
          this_case := this_descr;
        end; {start_case}


      procedure start_label_group(var block: basicblockptr);

{ Called when we first begin a set of case labels which can be expected
  to have code following it.

  If we have dead code (probably from a switch break), then this is the
  only way control can come and we do a restore-context.  However, if
  someone has placed this label inside of a statement we can't restore
  and it's his tough luck.  Sneakness will not win out.

  We also initialize some variables for searching for a match.
}

        var
          basecontext: boolean; {we are at the base level for the switch}
          restored: boolean; {context must be restored}
          oldblock: basicblockptr; {block which preceeds this one}
          j: reghashindex; { unsigned var for quicker mod }


        begin
          with this_case^ do
            begin
            basecontext := (contextlev = contextsp + overflowdepth) and
                           (loopd = loopdepth);
            otherflow := not deadcode;
            if basecontext then
              begin
              restored := deadcode and not removing and not lab_found;
              if swbreak_found then
                begin
                decr_deadcount;
                gotodead := gotodead - 1;
                end;
              swbreak_found := false;
              caselab_found := false;
              if foncount > savemaxfon then savemaxfon := foncount;
              if restored then foncount := saveminfon;
              end
            else
              begin
              restored := false;
              deadcode := deadcode and entry_dead;
              clearcontext;
              for j := 1 to regtablelimit do
                if regvars[j].worth >= 0 then
                  begin
                  regvars[j].varlife.lonmax := tnodetablesize;
                  regvars[j].varlife.fonmax := shortmaxint;
                  end;
              loopkill(0, maxlevel);
              if loopdepth > 0 then irreducible := true;
              {STH -- was   irreducible := true; }

              caselab_found := swbreak_found;
              end;

            if last_dead then decr_deadcount;
            last_dead := false;
            dead_exit(start_deadcount);

            if block = nil then
              begin
              oldblock := currentblock;
              if restored then
                begin
                restorecontext;
                savecontext;
                end
              else clearcontext;
              newblock(block, oldblock, false);
              if restored then
                begin
                currentblock^.restoreop := true;
                currentblock^.saveop := true;
                end;
              end;
            found := false;
            casedef_found := false;
            addpredsuccs(casetopblock, block);
            end;

          currentblock^.dominates := false;

          { Make certain block is labelled, and if it wasn't before, force
            walk to use the label on this block rather than skipping to
            a non-empty successor block.  This fixes an obscure bug involving
            Duff's device in which an unlabelled block was emitted then later
            labelled and referenced.
           }

          if currentblock^.blocklabel = 0 then
            begin
            currentblock^.forcelabel := true;
            currentblock^.blocklabel := newlabel;
            end;
        end; {start_label_group}


      procedure insert_caselab(lowval, highval: integer {label values} );

{ Read in and insert a case label.  If "block" is not nil, use it, otherwise
  create a new basic block and add it to the successors of the
  header block.
}

        var
          currentlow, currenthigh: integer; {the current label values}
          p1, p2: nodeindex; {for sorting label into a list}
          ptr, ptr2: nodeptr; {for access to nodes}


        begin
          with this_case^ do
            begin
            if lastnode = tnodetablesize then compilerabort(manynodes)
            else lastnode := lastnode + 1;
            if lastnode > maxnodes then maxnodes := lastnode;
            if bigcompilerversion then ptr := @(bignodetable[lastnode]);
            with ptr^ do
              begin
              { link all the labels in text order }
              nextstmt := lastlab;
              lastlab := lastnode;
              nodeform := stmtnode;
              stmtkind := caselabhdr;
              stmtblock := currentblock;
              stmtlabel := currentblock^.blocklabel;
              orderedlink := 0;
              currentlow := lowval;
              currenthigh := highval;
              if removing and (constvalue >= currentlow) and
                 (constvalue <= currenthigh) then
                begin
                found := true;
                ever_found := true;
                end;

              caselabellow := currentlow;
              caselabelhigh := currenthigh;
              end;

            { Sort into ordered chain }
            if firstorder = 0 then
              begin
              firstorder := lastnode;
              lastorder := lastnode;
              highlabel := currenthigh;
              lowlabel := currentlow;
              end
            else if lowlabel >= currentlow then
              begin
              if bigcompilerversion then ptr := @(bignodetable[lastnode]);
              ptr^.orderedlink := firstorder;
              firstorder := lastnode;
              lowlabel := currentlow;
              end
            else if highlabel < currenthigh then
              begin
              if bigcompilerversion then ptr := @(bignodetable[lastorder]);
              ptr^.orderedlink := lastnode;
              lastorder := lastnode;
              highlabel := currenthigh;
              end
            else
              begin
              p1 := firstorder;
              if bigcompilerversion then ptr := @(bignodetable[firstorder]);
              p2 := ptr^.orderedlink;
              if bigcompilerversion then ptr2 := @(bignodetable[p2]);
              while ptr2^.caselabelhigh < currentlow do
                begin
                p1 := p2;
                p2 := ptr2^.orderedlink;
                if bigcompilerversion then ptr2 := @(bignodetable[p2]);
                end;
              if bigcompilerversion then ptr := @(bignodetable[lastnode]);
              ptr^.orderedlink := p2;
              if bigcompilerversion then ptr2 := @(bignodetable[p1]);
              ptr2^.orderedlink := lastnode;
              end;
            end;
        end; {insert_caselab}


      procedure insert_casedef;

{ Take a case default label.
}

        var
          p: nodeptr; {for access to case top}


        begin
          with this_case^ do
            begin
            if bigcompilerversion then p := @(bignodetable[casetopstmt]);
            p^.casedefptr := currentblock;
            casedef_found := true;
            end;
        end; {insert_casedef}


      procedure end_label_group(otherlab: boolean {we had other labels} );

{ We have all of this group of labels, so we can decide if the code is
  dead.  "otherlab" is set if there were non-case labels on this statement.
}


        begin
          with this_case^ do
            begin
            if otherlab then otherflow := true;
            last_dead := removing and not otherlab and not found and
                         not (casedef_found and not ever_found);
            if last_dead then
              begin
              incr_deadcount;
              currentblock^.isdead := true;
              end;
            if casedef_found then ever_found := true;
            end;
        end; {end_label_group}


      procedure case_break(shdr: stmthdrtype { to C or not to C } );

{ Take and log a case break statement, which transfers control to the
  terminating statement of a case.
}

        var
          s: nodeindex; {for break statement}
          p: nodeptr; {for access to statement}


        begin
          with this_case^ do
            begin
            newstmt(s, shdr);
            if bigcompilerversion then p := @(bignodetable[s]);
            p^.targblock := tailblock;
            addpredsuccs(currentblock, tailblock);
            if not swbreak_found then
              begin
              swbreak_found := true;
              if language = c then
                begin {have to have a block for code}
                newblock(currentblock, currentblock, false);
                addpredsuccs(currentblock, currentblock);
                currentblock^.isdead := removedeadcode in genset;
                end;
              incr_deadcount;
              gotodead := gotodead + 1;
              end;
            end;
        end; {case_break}


      procedure split(first, last: nodeindex {limits of label list} );

{ Splits an ordered group of case labels into more economical groups.
  The starting point is to assume a jump table implementation.  Each
  split results in a pair of jump tables with a conditional jump to
  choose between them.  The result is a tree of jumps each ending
  in a jump table or single case label.  The tree is represented as
  an ordered list of entries.

  The strategy is to examine each possible split to see if it improves
  the overall size.  Once a split is made, teh procedure is called
  recursively to split the pieces.  Actually, since one of the pieces
  is the rest of the label list, tail recursion can be (and is) replaced
  by iteration.

  In this case, the only criterion for splitting is code size.  Speed
  could be taken into account if desired by adding a suitable weight
  and a raft of new constants.  Since a binary comparison tree is quite
  fast anyway, we are content with size.  Fudging constants can produce
  a good approximation to speed sensitivity anyway.
}

        var
          start: nodeindex; {start of current group}
          basecost: addressrange; {cost of implementation in bytes}
          this: nodeindex; {used to scan the labels}
          next: nodeindex; {next node in the scan}
          p: nodeptr; {for access to this}
          op: nodeptr; {access to orderedlink}
          thisisordered: boolean; {current group is contig ordered.}
          skipdone: boolean; {done skipping labels}


        procedure incref(n: nodeindex; {node to increment}
                         inc: integer {amount to increment} );

{ Chain down a list of copies incrementing ref and copy counts
  appropriately.
}

          var
            p: nodeptr; {for access to the node}
            first: boolean; {first node encountered}


          begin
            first := true;
            if bigcompilerversion then p := @(bignodetable[n]);
            while p^.action = copy do
              with p^ do
                begin
                refcount := refcount + inc;
                if not first then copycount := copycount + inc;
                first := false;
                n := p^.oldlink;
                if bigcompilerversion then p := @(bignodetable[n]);
                end;

            { We now have a "visit" node with an operation}
            if (p^.op < intop) and (p^.op > newunsvarop) then
              while p^.slink <> 0 do
                begin
                n := p^.slink;
                if bigcompilerversion then p := @(bignodetable[n]);
                end;

            if bigcompilerversion then p := @(bignodetable[n]);
            p^.refcount := p^.refcount + inc;
            if not first then p^.copycount := p^.copycount + inc;
            if p^.op = commaop then incref(p^.oprnds[2], inc);
          end; {incref}


        function orderedgroup(first, last: nodeindex): boolean;

{ Check if the group defined by first and last has contiguous labels
  all refering to the same statement
}

          var
            stillordered: boolean; {set as long as ordered so far}
            thislab: nodeindex; {used to trace list}
            tp, op: nodeptr; {for access to nodes}


          begin
            if bigcompilerversion then tp := @(bignodetable[first]);
            if bigcompilerversion then op := @(bignodetable[tp^.orderedlink]);

            stillordered := (first <> last) and (op^.orderedlink <> last);
            thislab := first;
            while stillordered and (thislab <> last) do
              begin
              if bigcompilerversion then tp := @(bignodetable[thislab]);
              if bigcompilerversion then
                op := @(bignodetable[tp^.orderedlink]);
              stillordered := (tp^.caselabelhigh = op^.caselabellow - 1) and
                              (tp^.stmtlabel = op^.stmtlabel);
              thislab := tp^.orderedlink;
              end;
            orderedgroup := stillordered;
          end; {orderedgroup}


        function cost(first, last: nodeindex): addressrange;

{ compute and return the cost in bytes of a jump table implementation
  to handle labels first through last.  The only special case is
  a single label.
}

          var
            fp, lp: nodeptr; {for access to node data}
            defaultcost: integer; {cost of a default}


          begin
            if this_case^.casedef_found then defaultcost := casedefaultcost
            else defaultcost := errdefaultcost;
            if bigcompilerversion then fp := @(bignodetable[first]);
            if bigcompilerversion then lp := @(bignodetable[last]);
            if fp^.caselabellow = lp^.caselabelhigh then
              cost := splitcost + defaultcost
            else
              begin
              if (fp^.orderedlink = last) and
                 (fp^.caselabellow = fp^.caselabelhigh) and
                 (lp^.caselabellow = lp^.caselabelhigh) or orderedgroup(first,
                 last) then
                cost := splitcost div 2 + splitcost + defaultcost
              else
                begin
                if maxint div caselabcost <=
                   lp^.caselabelhigh - fp^.caselabellow + 1 then
                  cost := maxint { overflow causes humungous case tables !! }
                else
                  cost := casetablecost + (lp^.caselabelhigh -
                          fp^.caselabellow + 1) * caselabcost;
                end;
              end;
          end; {cost}


        begin {split}
          with this_case^ do
            begin
            start := first;
            this := first;
            basecost := cost(first, last);
            thisisordered := false;
            if bigcompilerversion then p := @(bignodetable[caseexpr]);
            if not p^.relation then
              begin
              while this <> last do
                begin
                if bigcompilerversion then p := @(bignodetable[this]);
                next := p^.orderedlink;
                if (basecost = maxint) {humungous case statement} or
                   (cost(start, this) + cost(p^.orderedlink,
                   last) + splitcost < basecost) then
                  begin {a split is an improvement}
                  split(start, this); {split the first part}
                  incref(caseexpr, 2); {to compensate for extra refs}
                  start := next;
                  basecost := cost(start, last);
                  end;
                repeat
                  this := next;
                  if bigcompilerversion then p := @(bignodetable[this]);
                  next := p^.orderedlink;
                  if this = last then skipdone := true
                  else
                    begin
                    if bigcompilerversion then op := @(bignodetable[next]);
                    skipdone := (p^.stmtlabel <> op^.stmtlabel) or
                                (p^.caselabelhigh <> op^.caselabellow - 1);
                    end;
                until skipdone;
                end; {while}

              if bigcompilerversion then p := @(bignodetable[start]);

              { Now define the final split found.  Note that treatment of
                label ranges is imperfect, but shouldn't be far off.
              }
              thisisordered := orderedgroup(start, last) or (start = last) and
                               (p^.caselabellow <> p^.caselabelhigh) and
                               (basecost > splitcost + casedefaultcost);

              if bigcompilerversion then
                op := @(bignodetable[p^.orderedlink]);

              if (p^.orderedlink = last) and
                 (p^.caselabellow = p^.caselabelhigh) and
                 (op^.caselabellow = op^.caselabelhigh) or thisisordered then
                incref(caseexpr, 1);
              end;

            if lastnode = tnodetablesize then compilerabort(manynodes)
            else
              begin
              lastnode := lastnode + 1;
              if lastnode > maxnodes then maxnodes := lastnode;
              if bigcompilerversion then p := @(bignodetable[lastnode]);
              with p^ do
                begin
                stmtkind := casegroup;
                ordered := thisisordered;
                nextstmt := firstsplit;
                firstsplit := lastnode;
                textline := 0;
                lowestlabel := start;
                highestlabel := last;
                splitcount := splitcount + 1;
                groupno := splitcount;
                end;
              end;
            end;
        end; {split}


      procedure finish_case;

{ Finish a case statement.  All of the branches join here, and we may have
  to clean up some dead code garbage.  Finally we pop the case descriptor
  and get rid of it
}

        var
          tc: case_descriptor; {temp for disposal}
          p: nodeptr; {for access to node}


        begin {finish_case}
          with this_case^ do
            begin
            if swbreak_found then
              begin
              decr_deadcount;
              gotodead := gotodead - 1;
              end;
            if last_dead then decr_deadcount;
            dead_exit(start_deadcount);
            addpredsuccs(currentblock, tailblock);
            addpredsuccs(casetopblock, tailblock);
            if foncount > savemaxfon then savemaxfon := foncount;
            if not removing then
              begin
              restorecontext;
              joincontext;
              end;
            if bigcompilerversion then p := @(bignodetable[casetopstmt]);
            if removing then
              if (switchcounters[rangecheck] <= 0) or casedef_found or
                 ever_found then
                p^.stmtkind := nohdr
              else p^.stmtkind := caseerrhdr
            else
              begin
              p^.elements := firstorder;
              p^.joinblock := tailblock;
              if firstorder = 0 then increfcount(p^.selector, deadcode,
                                                 - ord(language <> C))
              else split(firstorder, lastorder);
              if bigcompilerversion then p := @(bignodetable[casetopstmt]);
              p^.firstgroup := firstsplit;
              p^.groupcount := splitcount;
              end;
            currentblock := tailblock;
            currentblock^.dominates := context[contextsp].dominates;

            { The tailblock might actually be a dead block if a return
              or goto statement terminated the last branch of the switch
              statement.  Newblock normally sets isdead, but the tail
              was created at the top, rather than bottom of the structure,
              i.e. out of context.
            }

            currentblock^.isdead := deadcode and (removedeadcode in genset);

            foncount := savemaxfon;
            caselab_found := old_caselab_found;
            swbreak_found := old_swbreak_found;
            end;
          tc := this_case;
          this_case := tc^.outer;
          dispose(tc);
        end; {finish_case}


      procedure buildcasestmt;

{ Build a case statement.  This is the most complicated of the
  statements.  The main statement is represented as a "casehdr"
  which holds limit and default data and points to a list of
  case elements in textual order.

  Each case element is represented by a "caselabhdr", which has
  contains the low and high values of one case range (with these
  values being equal for a simple case label).  Individual
  case label ranges are linked by the "nextstmt" field, and
  the selected statement is built in "stmt1".  "Stmt2" is used
  to point to the next case element.

  In addition to being linked in textual order, case labels are
  linked in numerical order through the "orderedlink" field, with
  the chain starting in the "firstlabel" field of the casehdr.
  Labels are sorted into this ordered chain as they are read in.
  Also, each case label has a link to the parent lab header.
  As each case element is built, the context is saved and restored
  for each branch of the case.  Finally, the context is joined at the
  end of the entire case.
}

        var
          caseblock: basicblockptr; {the block for each case piece}
          lowlabel: integer; {lower of the two labels from intermediate file}
          simplecaselab: boolean; { the simple, single value case }


        begin
          start_case;

          while tempfilebuf.s in [caselab, caselabrange] do
            begin {read each case element}
            caseblock := nil;
            start_label_group(caseblock);

            while tempfilebuf.s in [caselab, caselabrange] do
              begin {Read all labels for this element}
              simplecaselab := tempfilebuf.s = caselab;
              read(tempfiletwo, tempfilebuf);
              lowlabel := getintfileint;
              if simplecaselab then insert_caselab(lowlabel, lowlabel)
              else
                begin
                read(tempfiletwo, tempfilebuf);
                insert_caselab(lowlabel, getintfileint);
                end;
              read(tempfiletwo, tempfilebuf);
              end;

            end_label_group(false);
            buildstmtlist(endcaseelt, nil);
            case_break(swbrkhdr);
            end;

          if tempfilebuf.s = casedef then
            begin
            read(tempfiletwo, tempfilebuf);
            caseblock := nil;
            start_label_group(caseblock);
            insert_casedef;
            end_label_group(false);
            buildstmtlist(endcase, nil);
            case_break(swbrkhdr);
            end
          else
            begin
            this_case^.tailblock^.blocklabel := newlabel;
            read(tempfiletwo, tempfilebuf);
            end;

          finish_case;
        end {buildcasestmt} ;


      procedure buildcforstmt;

{ Build a C for statement node.  The context is cleared prior to evaluation
  of the boolean expression, since control may come from one of two
  places.  A savecontext and restorecontext around the controlled
  statement make common expressions from the boolean available on exit.
  Of course, the presence of a "break" in the loop makes such statements
  invalid.

  When the head of the loop is dead we still need to build it since
  we may enter the loop with a goto.  We can remove such code if we
  are still dead at the end of the loop.
}

        var
          hdrblock: basicblockptr; { index to for hdr block }
          tailblock: basicblockptr; { index to for bottom block }
          controlled: basicblockptr; { index to controlled block }
          exit_block: basicblockptr; { the exit from the loop }
          start_deadcount: natural; {the starting value of deadcount}
          start_dead: boolean; {dead at the start}
          ptr: nodeptr; { for access to nodes }
          cforhdrstmt: nodeindex; { index to while hdr }
          removing: boolean; { true if constant whileloop and deadcode goes }
          constvalue: integer; { value of control expression }
          p: nodeindex; { whilebotstmt index }


        begin

          start_deadcount := deadcount;
          start_dead := deadcode;
          if gotodead = deadcount then deadcode := false;

          clearcontext;
          newblock(hdrblock, currentblock, true);
          hdrblock^.blocklabel := newlabel;
          enterloop(hdrblock);
          newblock(tailblock, nil, false);
          newblock(exit_block, nil, false);
          currentblock := hdrblock;
          hdrblock^.clearop := not start_dead; ;

          shorteval := true;
          setupstmt(cforhdr);
          cforhdrstmt := thisstmt;
          if bigcompilerversion then ptr := @(bignodetable[cforhdrstmt]);
          checkconst(ptr^.expr1, removing, constvalue);
          removing := removing and (removedeadcode in genset);
          shorteval := false;
          newblock(controlled, hdrblock, false);
          if start_dead then controlled^.blocklabel := newlabel;

          if removing and (constvalue = 0) then incr_deadcount;

          context[contextsp].dominates := true;
          if bigcompilerversion then ptr := @(bignodetable[cforhdrstmt]);
          ptr^.trueblock := controlled;
          ptr^.falseblock := exit_block;
          hdrblock^.loophdr := true;

          pushloop(tailblock, exit_block);
          buildstmtlist(endcfor, nil);

          dead_exit(start_deadcount);
          addpredsuccs(currentblock, tailblock);
          currentblock := tailblock;
          currentblock^.dominates := context[contextsp].dominates;

          newstmt(p, cforbothdr);
          temp := buildexpr;
          increfcount(temp, deadcode, - 1);

          if bigcompilerversion then ptr := @(bignodetable[p]);
          ptr^.expr1 := temp;
          ptr^.trueblock := hdrblock;
          ptr^.falseblock := exit_block;
          { the bottom of the loop needs to know where the top is }
          ptr^.looptop := hdrblock;
          ptr^.has_break := this_loop^.break_found;

          addpredsuccs(currentblock, hdrblock);
          clearcontext;
          exitloop;

          if removing and (constvalue = 0) then
            begin
            removing := removing and deadcode;
            decr_deadcount;
            end;
          currentblock := exit_block;
          addpredsuccs(hdrblock, currentblock);
          currentblock^.dominates := context[contextsp].dominates;

          if bigcompilerversion then ptr := @(bignodetable[cforhdrstmt]);

          if removing then
            begin
            ptr^.stmtkind := nohdr;
            if (constvalue = 0) or start_dead then hdrblock^.loophdr := false
            else hdrblock^.willexecute := true;
            end;
          poploop;
        end; {buildcforstmt}


      procedure buildfor;

{ Build a for statement node.  The forstack is used to relate the
  for index variable to the for statement.  It is incremented at
  the start of the statement, and the variable level and displacement
  stored when the "def...forindex" operation is found in the expression.
  As this is a looping construct, the context must be cleared at the
  beginning of the controlled statements.
}

        var
          ptr: nodeptr; {Used to access controlled var/stmt nodes}
          fortopblock, { index to forloop top block }
           forbotblock, { index to forloop bottom block }
           forstmts: basicblockptr; { index to basic block containing body }
          forhdrstmt: nodeindex; { index to forhdr }
          p: nodeindex; { for acces to bottom stmt }
          saveexpr1, saveexpr2, controlledvar: nodeindex; { copies to
                                                           expressions at top
                                                           of loop }
          fixed: boolean; { true if constant for loop }
          overflow: boolean; { true if runcount is short }
          start_deadcount: natural; {starting value of deadcount}
          runcount: unsignedint; { number of times for loop executes }
          exitlabel: labelrange; { label assigne for loop exit }
          indexaddr: addressrange; { offset of for induction var }
          savedloopfactor: shortint; {saved value of current loop weight}


        begin {buildfor}

          start_deadcount := deadcount;
          newblock(fortopblock, currentblock, true);
          forsp := forsp + 1;

          setupstmt(foruphdr);

          { point hdr to for..indxop}
          if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
          forhdrstmt := thisstmt;
          ptr^.expr2 := stack[sp - 1].p;
          saveexpr1 := ptr^.expr1;
          saveexpr2 := ptr^.expr2;
          increfcount(ptr^.expr2, deadcode, 1);
          if tempfilebuf.s = fordn then
            begin
            if bigcompilerversion then ptr := @(bignodetable[forhdrstmt]);
            ptr^.stmtkind := fordnhdr;
            end;
          read(tempfiletwo, tempfilebuf);

          ptr^.forstepsize := getintfileint;
          read(tempfiletwo, tempfilebuf);

          if bigcompilerversion then ptr := @(bignodetable[saveexpr2]);
          controlledvar := ptr^.oprnds[2];

          estimateloop(forhdrstmt, fixed, overflow, runcount);

          if fixed and (runcount = 0) and (removedeadcode in genset) then
            begin
            if bigcompilerversion then ptr := @(bignodetable[forhdrstmt]);
            ptr^.stmtkind := nohdr; { kill it!}
            incr_deadcount;
            { need a dead block to hang these stmts on }
            newblock(forstmts, currentblock, false);
            buildstmtlist(endfor, nil);
            read(tempfiletwo, tempfilebuf); { who cares about jump out}
            decr_deadcount;
            newblock(currentblock, forstmts, false);
            end
          else { true "loop" }
            begin
            clearcontext;
            fortopblock^.loophdr := true;
            fortopblock^.willexecute := fixed and (runcount > 0);
            enterloop(fortopblock);
            if not (deadcode and (removedeadcode in genset)) then
              begin
              { now add the definition to the bitmap }
              if targetmachine = iapx86 then loopfactor := loopfactor - 5; {don't
                count for loop vars as much}
              dodefine(controlledvar);
              if targetmachine = iapx86 then loopfactor := loopfactor + 5;
              end;
            context[contextsp].dominates := true;
            { don't do a clearop since codegen does it free }
            newblock(forstmts, fortopblock, false);
            { dominate is harmless here, no code is present }
            newblock(forbotblock, nil, false);
            currentblock := forstmts;
            buildstmtlist(endfor, forbotblock);
            if getintfileint <> 0 then {there's a goto out of the loop}
              begin {clear the "local access only" flag}
              if bigcompilerversion then ptr := @(bignodetable[saveexpr2]);
              ptr^.oprnds[1] := 0;
              end;
            read(tempfiletwo, tempfilebuf);
            clearcontext;
            if (currentblock = forstmts) and false then
              begin
              { never generated any new blocks so merging block not needed }
              { dispose forbotblock }
              end
            else currentblock := forbotblock;
            newstmt(p, forbothdr);
            addpredsuccs(currentblock, fortopblock);

            { now add the implied var reference to the lifetimes }

            if not (deadcode and (removedeadcode in genset)) then
              doreference(controlledvar);

            { don't do a clearop since codegen does it free }

            newblock(currentblock, fortopblock, false);

            { the bottom of the loop needs to know where the top is }

            if bigcompilerversion then ptr := @(bignodetable[p]);
            ptr^.looptop := fortopblock;

            if bigcompilerversion then ptr := @(bignodetable[forhdrstmt]);

            ptr^.falseblock := currentblock;
            ptr^.trueblock := forstmts;
            exitloop;
            { update for any goto's within the loop }
            with currentblock^ do dominates := context[contextsp].dominates;
            end;

          dead_exit(start_deadcount);
          forsp := forsp - 1;

        end {buildfor} ;


      procedure buildwhilestmt;

{ Build a while statement node.  The context is cleared prior to evaluation
  of the boolean expression, since control may come from one of two
  places.  A savecontext and restorecontext around the controlled
  statement make common expressions from the boolean available on exit.

  The presence of a "break" statement within the loop invalidates these
  statements.

  We also have to allocate the exit block at the start of the loop,
  since break statements need to make themselves predecessors to it.
}

        var
          hdrblock: basicblockptr; { index to while hdr block }
          tailblock: basicblockptr; { index to while bottom block }
          controlled: basicblockptr; { index to controlled block }
          exit_block: basicblockptr; { the exit block }
          start_deadcount: natural; {starting value for deadcount}
          start_dead: boolean; {we started out dead}
          ptr: nodeptr; { for access to nodes }
          whilehdrstmt: nodeindex; { index to while hdr }
          removing: boolean; { true if constant whileloop and deadcode goes}
          constvalue: integer; { value of control expression }
          p: nodeindex; { whilebotstmt index }


        begin {buildwhilestmt}

          start_deadcount := deadcount;
          start_dead := deadcode and (removedeadcode in genset);
          if gotodead = deadcount then deadcode := false;

          clearcontext;
          newblock(hdrblock, currentblock, true);
          newblock(exit_block, nil, false);
          currentblock := hdrblock;
          { must enterloop always so that refs in control stmt are linked}
          enterloop(hdrblock);
          hdrblock^.clearop := not start_dead;

          shorteval := true;
          setupstmt(whilehdr);
          whilehdrstmt := thisstmt;
          if bigcompilerversion then ptr := @(bignodetable[whilehdrstmt]);
          checkconst(ptr^.expr1, removing, constvalue);
          removing := removing and (removedeadcode in genset);
          shorteval := false;

          savecontext;
          if removing and (constvalue = 0) then incr_deadcount;
          context[contextsp].dominates := true;
          newblock(tailblock, nil, false);
          newblock(controlled, hdrblock, false);
          if start_dead then controlled^.blocklabel := newlabel;
          hdrblock^.loophdr := true;

          if bigcompilerversion then ptr := @(bignodetable[whilehdrstmt]);
          ptr^.trueblock := controlled;
          ptr^.falseblock := exit_block;

          pushloop(hdrblock, exit_block);
          buildstmtlist(endwhile, tailblock);

          { need a place to hang the restore loop pseudoop }

          currentblock := tailblock;

          currentblock^.dominates := context[contextsp].dominates;

          newstmt(p, whilebothdr);
          { tell bottom of loop where top is ( minus precode ) }
          if bigcompilerversion then ptr := @(bignodetable[p]);
          ptr^.looptop := hdrblock;

          addpredsuccs(currentblock, hdrblock);
          exitloop;

          if this_loop^.break_found then popcontext
          else restorecontext;

          ptr^.has_break := this_loop^.break_found;

          currentblock^.restoreop := true;
          controlled^.saveop := true;

          if removing and (constvalue = 0) then decr_deadcount;
          currentblock := exit_block;
          addpredsuccs(hdrblock, exit_block);
          currentblock^.dominates := context[contextsp].dominates;

          if bigcompilerversion then ptr := @(bignodetable[whilehdrstmt]);
          if removing then
            begin
            ptr^.stmtkind := nohdr;
            if (constvalue = 0) or start_dead then hdrblock^.loophdr := false
            else hdrblock^.willexecute := true;
            end;

          dead_exit(start_deadcount);
          poploop;
        end; {buildwhilestmt}


      procedure buildloopstmt;

{ Build a loop statement node.  The context is cleared prior to the
  controlled statements, and afterwards as well, as there may well
  be multiple exits from inside the loop.
}

        var
          ptr: nodeptr; {to access stmt node}
          p: nodeindex; {hold fn result till usable}
          start_deadcount: natural; {deadcount at top of loop}
          prevblock, {block preceding loop body}
           exitblock, {block after loop body}
           tailblock, {block trailing loop body}
           loopbody: basicblockptr; {block containing loop body}


        begin {buildloopstmt}

          start_deadcount := deadcount;
          if gotodead = deadcount then deadcode := false;

          newblock(loopbody, currentblock, true);
          with loopbody^ do
            begin
            clearop := true;
            willexecute := true;
            end;
          clearcontext;
          newblock(tailblock, loopbody, false);
          newblock(exitblock, nil, false);
          tailblock^.clearop := true;
          currentblock := loopbody;

          newstmt(thisstmt, loophdr);
          read(tempfiletwo, tempfilebuf);

          enterloop(loopbody);
          pushloop(loopbody, exitblock);
          this_loop^.looploop := true;
          buildstmtlist(endloop, tailblock);
          currentblock := tailblock;
          { update control block dominate value to proper value }
          currentblock^.dominates := context[contextsp].dominates;
          addpredsuccs(currentblock, loopbody);
          loopbody^.loophdr := true;
          loopbody^.blocklabel := newlabel;
          clearcontext;
          newstmt(p, loopbothdr);
          { tell bottom of loop where top is ( minus precode ) }
          if bigcompilerversion then ptr := @(bignodetable[p]);
          ptr^.looptop := loopbody;

          exitloop;
          dead_exit(start_deadcount);

          ptr^.has_break := this_loop^.break_found;

          addpredsuccs(currentblock, exitblock);
          currentblock := exitblock;
          currentblock^.dominates := context[contextsp].dominates;
          poploop;

        end {buildloopstmt} ;


      procedure buildrptstmt;

{ Build a repeat statement node.  The context is cleared prior to the
  controlled statements, but need not be cleared on exit, making
  expressions from within available.

  We create a dummy statement at the end of the loop to provide for
  copy-nodes needed to evaluate the controlling expression.  The "prestmt"
  field for this context level may have disappeared due to a clearcontext
  operation, in which case the insertnode mechanism has no place to build
  the needed copy-nodes.  So we provide a fake place, and explicitly walk
  the copy-nodes hung on this statement (if any) in "walkrpt".

  We need access to the exit block while building the loop body, so
  we use the "falseblock" field in the until header to hold it.
  Context is cleared befor the control expression if we have a "continue",
  and before the exit block if we have a "break".
}

        var
          ptr: nodeptr; { to access stmt node }
          temp: nodeindex; { hold fn result till usable }
          loopbody: basicblockptr; { block containing loop body }
          control: basicblockptr; { block containing loop control }
          exit_block: basicblockptr; {the exit block}
          start_deadcount: natural; {starting value of deadcount}
          constvalue: integer; { value of control expression }
          removing: boolean; { true if control expr is constant and dead goes}
          untilstmt: nodeindex; { index of untilhdr }
          exitdead: boolean; {the exit block is dead}
          startdead: boolean; {we were dead at entry}


        begin
          start_deadcount := deadcount;
          startdead := deadcode;
          if gotodead = deadcount then deadcode := false;
          newblock(loopbody, currentblock, true);
          with loopbody^ do
            begin
            clearop := not startdead;
            willexecute := true;
            end;
          newblock(control, nil, false);
          newblock(exit_block, nil, false);
          clearcontext;
          currentblock := loopbody;

          newstmt(thisstmt, rpthdr);
          read(tempfiletwo, tempfilebuf);

          enterloop(loopbody);
          pushloop(control, exit_block);
          buildstmtlist(endrpt, control);
          if this_loop^.cont_found then dead_exit(start_deadcount);
          exitdead := deadcode and (removedeadcode in genset);
          shorteval := true;

          currentblock := control;

          if irreducible then loopbody^.clearop := false;

          currentblock^.dominates := context[contextsp].dominates;
          newstmt(untilstmt, untilhdr);

          if this_loop^.cont_found then clearcontext;

          temp := buildexpr;
          checkconst(temp, removing, constvalue);
          if exitdead and not removing then
            begin
            removing := (removedeadcode in genset);
            constvalue := 1;
            end
          else removing := removing and (removedeadcode in genset);

          { loopbody follows control ( unless dead control ) }

          if exitdead then
            begin
            addpredsuccs(exit_block, exit_block);
            exit_block^.isdead := removedeadcode in genset;
            end;
          addpredsuccs(control, exit_block);

          if not removing or (constvalue = 0) then
            begin
            addpredsuccs(control, loopbody);
            loopbody^.loophdr := true;
            loopbody^.blocklabel := newlabel;
            end;

          shorteval := false;
          exitloop;

          if this_loop^.break_found then clearcontext;

          if bigcompilerversion then ptr := @(bignodetable[untilstmt]);
          if removing and (constvalue = 1) then ptr^.stmtkind := nohdr
          else
            begin
            { kill the expression on an "infinite" loop }
            if removing then ptr^.expr1 := 0
            else ptr^.expr1 := temp;
            ptr^.falseblock := loopbody;
            ptr^.trueblock := exit_block;
            ptr^.has_break := this_loop^.break_found;
            end;

          if not this_loop^.cont_found then dead_exit(start_deadcount);

          currentblock := exit_block;
          currentblock^.dominates := context[contextsp].dominates;
          poploop;
        end {buildrptstmt} ;


      procedure buildwithstmt;

{ Build a with statement node.  The with stack is used to keep track
  of the with temporary pointer.
}

        var
          ptr: nodeptr; {used to access stmt node}
          tempthisstmt: nodeindex; { simulate time machine }
          withvar: nodeindex; { index of the varop being "withed"}
          temp: nodeindex; { hold fn result till usable }
          endblock, { index to block at with end }
           withstmts: basicblockptr; { block containing with stmts }
          savedominate: boolean; { value of context's dominates field before
                                  savecontext }
          i: reghashindex;


        begin {buildwithstmt}

          withsp := withsp + 1;
          with withstack[withsp] do
            begin
            withlevel := contextsp;
            withfonmin := foncount;
            setupstmt(withhdr);
            withfoncount := foncount;
            if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
            withref := ptr^.expr1;
            increfcount(withref, deadcode, - 1);
            { must remove as register candidate}
            if not deadcode then
              begin
                { first we must find the var, if the
                  with is like with p^ then p is ok as register
                  var ( on machines with ptrreg ).
                }
              if bigcompilerversion then ptr := @(bignodetable[withref]);
              { now have the indxop, get the varop }
              if ptr^.op <> indxop then
                begin
                writeln('in buildwith, expr not a indxop is ', ord(ptr^.op): 1);
                compilerabort(inconsistent);
                end;
              withvar := ptr^.oprnds[1];
              if bigcompilerversion then ptr := @(bignodetable[withvar]);
              if not (ptr^.op in [varop, newvarop, unsvarop, newunsvarop]) then
                begin
                writeln('in buildwith, var not a varop is ', ord(ptr^.op): 1);
                compilerabort(inconsistent);
                end;
              { pointer dereference will have level of zero, which is ok }
              if ptr^.oprnds[1] = level then killasreg(withvar);
              end;
            end;

          { with block dominates if current context dominates }
          savedominate := context[contextsp].dominates;
          savecontext;
          newblock(withstmts, currentblock, false);
          { set the proper value of dominate }
          currentblock^.dominates := savedominate;
          context[contextsp].dominates := savedominate;
          with withstmts^ do
            begin
            saveop := true;
            end;
          newblock(endblock, nil, false);
          with endblock^ do
            begin
            joinop := true;
            restoreop := true;
            end;
          currentblock := withstmts;
          { do we need to reset firstblock here, not really a new block ?? }
          buildstmtlist(endwith, endblock);
          restorecontext;

          { Extend the lifetime of any variable mentioned in the with expr }

          for i := 0 to regtablelimit do
          begin
          with regvars[i], varlife do
            begin
            if (worth > 0) and ((fonmin >= withstack[withsp].withfonmin) or
               (fonmax >= withstack[withsp].withfonmin)) and
               (fonmin <= withstack[withsp].withfoncount) then
              begin
              lonmax := lastnode;
              { never let fonmax decrease!}
              if foncount > fonmax then fonmax := foncount;
              end;
            end;
          end;

          withsp := withsp - 1;
          joincontext;
          currentblock := endblock;

        end {buildwithstmt} ;


      procedure builddeflabel(var lblock: basicblockptr);

{ Build a label node.  This is treated as a statement in itself.
  The context is cleared because it is impossible to tell from
  where the jump may have come.
  Lblock is set to the resulting block.
}

        var
          ptr: nodeptr; { to access stmt node }
          mylabel: integer; { value of this label }
          lptr: locallabelptr; { for walking label chains }
          found: boolean; { true if label found }
          j: reghashindex; { induction var}
          cp: case_descriptor;


        begin {builddeflabel}
          if (gotodead = deadcount) or (language = c) then deadcode := false;{could
            be from outside}
          clearcontext;
          read(tempfiletwo, tempfilebuf);
          mylabel := getintfileint;
          { define the label and allocate a new block, unless already defined }
          lptr := locallabels;
          found := false;
          while (lptr <> nil) and not found do
            if lptr^.labelno = mylabel then found := true
            else lptr := lptr^.link;
          if found then
            begin
            addpredsuccs(currentblock, lptr^.block);
            currentblock := lptr^.block;
            currentblock^.isdead := (deadcode and (removedeadcode in genset));
            end
          else
            begin
            new(lptr);
            lptr^.link := locallabels;
            lptr^.labelno := mylabel;
            { define the start of a new block }
            { no need to do clearop, genblk will do it free }
            if lblock = nil then newblock(currentblock, currentblock, false)
            else currentblock := lblock;
            lptr^.block := currentblock;
            locallabels := lptr;
            end;
          lblock := currentblock;
          if lblock^.blocklabel = 0 then lblock^.blocklabel := newlabel;

          newstmt(thisstmt, labelhdr);
          if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
          ptr^.labelno := mylabel;
          read(tempfiletwo, tempfilebuf);
          ptr^.labellevel := getintfileint;
          read(tempfiletwo, tempfilebuf);
          ptr^.nonlocalref := (getintfileint = 1);
          { using simple minded approach, lifetime analysis is invalid,
            defeat multiple vars to single register assignment
          }
          for j := 0 to regtablelimit do
            if regvars[j].worth >= 0 then
              begin
              { set lifetime region to encompass entire block }
              regvars[j].varlife.lonmax := tnodetablesize;
              regvars[j].varlife.fonmax := shortmaxint;
              end;
          { again using the simple minded approach, kill hoisting in
            any loop with a label in it.
          }
          loopkill(0, maxlevel);
          if loopdepth > 0 then irreducible := true;
          {STH -- was   irreducible := true; }

          if language = c then
            begin
            cp := this_case;
            while cp <> nil do
              begin
              cp^.lab_found := true;
              cp := cp^.outer;
              end;
            end;

          read(tempfiletwo, tempfilebuf);

        end {builddeflabel} ;


      procedure buildgotostmt;

{ Build a goto statement node.  If it is a local goto must fix the
  pred/succ chains.
}

        var
          ptr: nodeptr; { for access to node }
          mylabel: labelrange; { target of goto }
          mylevel: levelindex; { level of goto label }
          lptr: locallabelptr; { for walking label chains }
          found: boolean; { true if label found }
          gotoblock: basicblockptr; { block with goto stmt }
          unreach: basicblockptr; {for unreachable code}
          i: contextindex; { induction var }


        begin {buildgoto}

          if deadcode and (removedeadcode in genset) then
            begin
            { ignore this stmt}
            newstmt(thisstmt, gotohdr);
            read(tempfiletwo, tempfilebuf);
            mylabel := getintfileint;
            read(tempfiletwo, tempfilebuf);
            mylevel := getintfileint;
            read(tempfiletwo, tempfilebuf);
            end
          else
            begin
            { no longer can calculate dominators }
            for i := 2 to contextsp do context[i].dominates := false;
            newstmt(thisstmt, gotohdr);
            read(tempfiletwo, tempfilebuf);
            if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
            mylabel := getintfileint;
            ptr^.labelno := mylabel;
            read(tempfiletwo, tempfilebuf);
            mylevel := getintfileint;
            ptr^.labellevel := mylevel;
            read(tempfiletwo, tempfilebuf);
            gotoblock := currentblock;
            {this used to be below, not here:}
            newblock(unreach, gotoblock, false);
            addpredsuccs(unreach, unreach);
            unreach^.isdead := removedeadcode in genset;

            if level = mylevel then
              begin
              lptr := locallabels;
              found := false;
              while (lptr <> nil) and not found do
                if lptr^.labelno = mylabel then found := true
                else lptr := lptr^.link;
              if found then
               {  If the label has already been defined, we may wish to
                  add it as a successor of the goto block, as later activity
                  might change the order of execution, perhaps into something
                  more efficient.  However, we don't want to reorder blocks
                  which have context operators associated with them!  Pascal
                  and Modula-2 (real computer languages) place restrictions
                  on goto targets which guarantee that this situation won't
                  occur, however, C (fake computer language) allows gotos
                  to go to anywhere, thus them C hackers are s.o.l.
                }
                with lptr^, block^ do
                  if (language <> c) then addpredsuccs(gotoblock, block)
                  else
                    begin
                    new(lptr);
                    lptr^.link := locallabels;
                    lptr^.labelno := mylabel;
                    newblock(currentblock, gotoblock, false);
                    lptr^.block := currentblock;
                    locallabels := lptr;
                    end;
              end;

            currentblock := unreach;
            { This code used to be here, not above:
            newblock(unreach, gotoblock, false);
            addpredsuccs(unreach, unreach);
            unreach^.isdead := removedeadcode in genset;
            }
            if deadcount = gotodead then
              begin
              incr_deadcount; {code following is dead}
              gotodead := gotodead + 1;
              end;
            end;
        end {buildgoto} ;


      procedure buildsimplestmt(s: stmthdrtype {simple or hidden?} );

{ Build a node for an assignment or procedure call.  These are lumped
  together because all of the real work is done as an expression
  and there is no control flow to worry about.  The reference count of
  the (optional) expression is decremented, as this is one use of the
  expression complete.
}

        var
          ptr: nodeptr; {used to access node}


        begin {buildsimplestmt}
          setupstmt(s);
          if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
          if ptr^.expr1 <> 0 then increfcount(ptr^.expr1, deadcode, - 1);
        end {buildsimplestmt} ;


      procedure buildreturn;

{ Build a return statement, which is very similar to a simple statement
  except that it transfers control to "tail"
}

        var
          ptr: nodeptr; {for access to label}
          i: contextindex; {induction var}
          deadblock: basicblockptr;


        begin
          setupstmt(returnhdr);
          if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
          if ptr^.expr1 <> 0 then increfcount(ptr^.expr1, deadcode, - 1);
          ptr^.trueblock := retblock;
          addpredsuccs(currentblock, retblock);
          if not (deadcode and (removedeadcode in genset)) then
            for i := 2 to contextsp do context[i].dominates := false;

          newblock(deadblock, currentblock, false);
          addpredsuccs(deadblock, deadblock);
          deadblock^.isdead := removedeadcode in genset;
          if deadcount = gotodead then
            begin
            incr_deadcount;
            gotodead := gotodead + 1;
            end;
        end; {buildreturn}


      procedure finishswitch;


        begin
          finish_case;
          read(tempfiletwo, tempfilebuf);
        end;


      procedure buildlabel;

{ Build a sequence of labels.  Since we may well have many labels on
  a particular block, we want to create only one block and attach
  labels to it.  Of these labels, only a "deflabel" with an out
  of block goto may have any associated code.  "deflabel" instructions
  may already have an associated block, so we can't just create one
  out of hand.  We keep a "label_block" which is the block to which
  labels are to be attached.  A routine may disregard the existing
  block and append a new one if it needs to.  In such a case, the
  new block will be used for further labels.
}

        var
          label_block: basicblockptr; {the label block}
          s: stmttype;
          lab: integer; {case label, if any}
          swlab: boolean; {we found at least on switch label}
          full_lab: boolean; {we have a fully general label}


        begin
          label_block := nil; {none to begin with}
          s := tempfilebuf.s;
          swlab := false;
          full_lab := false;
          while s in [deflab, caselab, casedef] do
            begin
            if (s = caselab) or (s = casedef) then
              begin
              if not swlab then start_label_group(label_block);
              swlab := true;
              read(tempfiletwo, tempfilebuf);
              if s = caselab then
                begin
                lab := getintfileint;
                insert_caselab(lab, lab);
                read(tempfiletwo, tempfilebuf);
                end
              else insert_casedef;
              end
            else
              begin
              full_lab := true;
              builddeflabel(label_block);
              end;
            s := tempfilebuf.s;
            end;
          if swlab then end_label_group(full_lab);
        end; {buildlabel}


      procedure buildsyscallstmt;

{ Build a system call statement.  This is another simple statement, but
  is handled separately as it has an additional argument to choose the
  kind of system call.
}

        var
          ptr: nodeptr; {for access to node}
          temp: nodeindex; {hold fn result to usable}
          tempthisstmt: nodeindex; {simulate time machine}


        procedure clobberinput;
            {
              Find the variable "input" and make it unavailable.
            }

          var
            nindex: nodeindex; { for walking chains }
            ptr: nodeptr; {used for access to nodes}
            i: integer; { induction var }


          begin {clobberinput}
            for i := context[contextsp].searchlevel to contextsp do
              begin
              nindex := context[i].opmap[0];
              while nindex <> 0 do
                begin
                if bigcompilerversion then ptr := @(bignodetable[nindex]);
                with ptr^ do
                  begin
                  if (oprnds[1] = 1) and (oprnds[2] = inputoffset) and
                     ((op = varop) or (op = unsvarop)) then
                    begin
                    if not bigcompilerversion then
                      blocksin[1].written := blocksin[1].written or valid or
                                             (deepestvalid > contextsp);
                    valid := false;
                    if deepestvalid > contextsp then
                      begin
                      deepestvalid := contextsp;
                      end;
                    end;
                  nindex := slink;
                  end;
                end; {while}
              end; {for}
          end {clobberinput} ;


        begin {buildsyscallstmt}
          newstmt(thisstmt, syscallhdr);
          read(tempfiletwo, tempfilebuf);
          if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
          ptr^.expr2 := getintfileint;
{
            We must produce the effect of doing a newvar on input if read
            or readln were seen without a filevar present.
}
          killinput := (ptr^.expr2 = ord(readid)) or
                       (ptr^.expr2 = ord(readlnid));
          read(tempfiletwo, tempfilebuf);
          temp := buildexpr;
          if bigcompilerversion then ptr := @(bignodetable[thisstmt]);
          ptr^.expr1 := temp;
          if killinput then clobberinput;
        end {buildsyscallstmt} ;


      procedure buildlbreak(onlyloop: boolean {only exit "loop" loop} );

{ Build a loop break statement.  This statement transfers control directly
  to the end of the loop, thus it doesn't disturb dominator calculations.
  The header contains a link to the loop header so we can find the exit
  block when walking the tree.  We have to create a block for any
  unreachable code which may follow the break.

  If "onlyloop" is true we search for the nearest enclosing "loop" statement,
  rather than any vanilla loop construct.  This corresponds to Modula-2's
  "exit" statement.  However, the code is generalized to minimize the language
  dependency of travrs.
}

        var
          p: nodeptr; {for access to a node}
          breakloop: loop_descriptor; {the loop we will actually "break" from}


        begin
          newstmt(thisstmt, loopbrkhdr);
          read(tempfiletwo, tempfilebuf);
          if bigcompilerversion then p := @(bignodetable[thisstmt]);
          breakloop := this_loop;
          while onlyloop and not breakloop^.looploop do
            breakloop := breakloop^.outer;
          p^.targblock := breakloop^.break_block;
          with breakloop^.break_block^ do
            if blocklabel = 0 then blocklabel := newlabel;
          breakloop^.break_found := true;
          addpredsuccs(currentblock, breakloop^.break_block);
          newblock(currentblock, currentblock, false);
          addpredsuccs(currentblock, currentblock);
          currentblock^.isdead := removedeadcode in genset;
          incr_deadcount;
          gotodead := gotodead + 1;
        end; {buildlbreak}


      procedure buildlcont;

{ This is very similar to break except that it causes a transfer to the
  loop repetition code.  Since it always does a transfer to the increment
  and testing code, which dominates the exit, domination calculations are
  unchanged.
}

        var
          p: nodeptr; {for access to a node}


        begin
          newstmt(thisstmt, loopconthdr);
          read(tempfiletwo, tempfilebuf);
          if bigcompilerversion then p := @(bignodetable[thisstmt]);
          p^.targblock := this_loop^.cont_block;
          with this_loop^.cont_block^ do
            if blocklabel = 0 then blocklabel := newlabel;
          this_loop^.cont_found := true;
          addpredsuccs(currentblock, this_loop^.cont_block);
          newblock(currentblock, currentblock, false);
          addpredsuccs(currentblock, currentblock);
          currentblock^.isdead := removedeadcode in genset;
          incr_deadcount;
          gotodead := gotodead + 1;
        end; {buildlcont}


      procedure buildsbreak;


        begin
          case_break(cswbrkhdr);
          read(tempfiletwo, tempfilebuf);
        end;


      begin {buildstmt}
        case tempfilebuf.s of
          begif: buildifstmt;
          begcase: buildcasestmt;
          begcfor: buildcforstmt;
          begfor: buildfor;
          begwhile: buildwhilestmt;
          begloop: buildloopstmt;
          begrpt: buildrptstmt;
          begwith: buildwithstmt;
          begreturn: buildreturn;
          begswitch: start_case;
          caselab: buildlabel;
          casedef: buildlabel;
          endswitch: finishswitch;
          deflab: buildlabel;
          gotolab: buildgotostmt;
          simple: buildsimplestmt(simplehdr);
          hiddenstmt: buildsimplestmt(nohdr);
          syscall: buildsyscallstmt;
          loopbreak: buildlbreak(false);
          begexit: buildlbreak(true);
          loopcont: buildlcont;
          switchbreak: buildsbreak;
          begdata: passdata;
          blksize:
            begin
            while deadcode do decr_deadcount;
            read(tempfiletwo, tempfilebuf);
            final_block_size := getintfileint;
            read(tempfiletwo, tempfilebuf);
            end;
          otherwise
            begin
            writeln('travrs: unhandled stmt operator #',
                    ord(tempfilebuf.s): 0);
            compilerabort(builderror);
            end;
          end;

      end {buildstmt} ;


    begin {buildstmtlist}
      if not (deadcode and (removedeadcode in genset)) then
        foncount := foncount + 1;
      while tempfilebuf.s <> lasts do buildstmt;
      addpredsuccs(currentblock, successorblock);
      read(tempfiletwo, tempfilebuf);
    end {buildstmtlist} ;


  begin {build}

    read(tempfiletwo, tempfilebuf);

    initbuild;

    { tail is allocated large since it is handed out when newblock
      sees that we are building a deadblock therefore it must be full size.
    }
    newblock(tail, nil, true);
    newblock(retblock, nil, false);
    retblock^.blocklabel := newlabel;
    newblock(root, nil, false);
    newstmt(temp, blkhdr);
    buildstmtlist(endblk, retblock);
    addpredsuccs(retblock, tail);

    { kill any stmts from deadcode hooked to tail }

    with tail^ do
      begin
      isdead := true;
      precode := 0;
      beginstmt := 0;
      joinop := false;
      saveop := false;
      restoreop := false;
      clearop := false;
      loophdr := false;
      looplabel := 0;
      reads := 0;
      writes := 0;
      lastwrite := 0;
      end;

    symbolrecord := getintfileint;
    read(tempfiletwo, tempfilebuf);
    lastblock := nil;

    { reverse the state of visited blocks }

    visitstate := not visitstate; { true}
    retblock^.visited := visitstate;
    searchdfo(root, lastblock);
    tail^.visited := visitstate;
    retblock^.dfolist := tail;
    b := root;
    while b^.dfolist <> nil do b := b^.dfolist;
    b^.dfolist := retblock;

    { reverse the state of visited blocks }

    visitstate := not visitstate; { false}
    buildrdfo(root, nil);

    { now dispose of any local label garbage }

    while locallabels <> nil do
      begin
      templink := locallabels;
      locallabels := locallabels^.link;
      dispose(templink);
      end;
  end {build} ;




procedure travrs;


  begin {travrs}

    inittravrs;

    read(tempfiletwo, tempfilebuf);
    while tempfilebuf.s <> endall do
      begin

      while tempfilebuf.s = begdata do passdata;

      if tempfilebuf.s <> endall then
        begin
        build;
        improve.improve;
        walk.walk;
        end;
      end;

    if switcheverplus[test] and switcheverplus[details] then
      begin
      if hoistone <> 0 then writeln(hoistone: 1, ' invariants hoisted');
      if hoisttwo <> 0 then writeln(hoisttwo: 1, ' second level hoists');
      writeln((maxnodes * sizeof(node)): 1, ' bytes of node storage used.');
      end
    else if switchcounters[tswitch0] > 0 then
      writeln('travrs, last node was ', maxnodes: 1);
    close(locals);
  end {travrs} ;
end.
